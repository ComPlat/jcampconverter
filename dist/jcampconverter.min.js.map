{"version":3,"sources":["webpack:///jcampconverter/webpack/universalModuleDefinition","webpack:///jcampconverter/jcampconverter.min.js","webpack:///jcampconverter/webpack/bootstrap 31c0ce823b044a152453","webpack:///jcampconverter/./src/index.js","webpack:///jcampconverter/./src/parseXYData.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","getConverter","convertToFloatArray","stringArray","l","length","floatArray","Array","i","parseFloat","convert","jcamp","options","keepRecordsRegExp","ldr","dataLabel","dataValue","ldrs","ii","position","endLine","infos","start","Date","ntuples","result","profiling","logs","spectra","info","spectrum","push","action","time","split","replace","indexOf","substring","trim","toUpperCase","xIndex","yIndex","firstVariable","secondVariable","symbol","first","firstX","firstY","last","lastX","lastY","vardim","nbPoints","factor","xFactor","yFactor","units","xUnit","yUnit","datatable","deltaX","title","dataType","twoD","observeFrequency","xType","indirectFrequency","shiftOffsetNum","shiftOffsetVal","varname","ntuplesSeparator","vartype","varform","min","max","yType","page","pageValue","pageSymbol","pageSymbolIndex","unit","prepareSpectrum","match","fastParse","parseXYDataRegExp","fastParseXYData","parsePeakTable","isMSField","convertMSFieldToLabel","Object","keys","newNtuples","key","values","j","add2D","keepSpectra","isGCMS","newGCMS","xy","data","newData","x","y","k","addNewGCMS","addGCMS","value","toLowerCase","GC_MS_FIELDS","gcms","times","series","name","dimension","existingGCMSFields","label","gc","ms","shift","convertTo3DZ","noise","minZ","maxZ","ySize","xSize","z","Math","abs","minX","maxX","minY","maxY","zData","contourLines","generateContourLines","minMax","povarHeight0","povarHeight1","povarHeight2","povarHeight3","isOver0","isOver1","isOver2","isOver3","pAx","pAy","pBx","pBy","lineZValue","contourLevels","nbLevels","nbSubSpectra","nbPovars","x0","xN","dx","y0","yN","dy","level","contourLevel","side","exp","lines","zValue","iSubSpectra","povar","segments","isXYdata","currentData","currentPosition","currentX","currentY","ascii","charCodeAt","newLine","isDifference","isLastDifference","lastDifference","isDuplicate","inComment","currentValue","isNegative","inValue","skipFirstValue","decimalPosition","pow","duplicate","ascii2","removeCommentRegExp","peakTableSplitRegExp","isPeaktable","jj","JcampConverter","input","useWorker","postToWorker","worker","createWorker","Promise","resolve","stamp","now","random","stamps","postMessage","workerURL","URL","createObjectURL","Blob","toString","type","Worker","revokeObjectURL","addEventListener","event","output","xyDataSplitRegExp","DEBUG","lastDif","firstPoint","expectedCurrentX","String","fromCharCode","dup"],"mappings":"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","file":"jcampconverter.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JcampConverter\"] = factory();\n\telse\n\t\troot[\"JcampConverter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JcampConverter\"] = factory();\n\telse\n\t\troot[\"JcampConverter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar parseXYDataRegExp=__webpack_require__(1);\n\t\n\t\n\tfunction getConverter() {\n\t\n\t    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n\t    var ntuplesSeparator = /[, \\t]{1,}/;\n\t\n\t    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\t\n\t    function convertToFloatArray(stringArray) {\n\t        var l = stringArray.length;\n\t        var floatArray = new Array(l);\n\t        for (var i = 0; i < l; i++) {\n\t            floatArray[i] = parseFloat(stringArray[i]);\n\t        }\n\t        return floatArray;\n\t    }\n\t\n\t    /*\n\t     options.keepSpectra: keep the original spectra for a 2D\n\t     options.xy: true // create x / y array instead of a 1D array\n\t     options.keepRecordsRegExp: which fields do we keep\n\t     */\n\t\n\t    function convert(jcamp, options) {\n\t        options = options || {};\n\t\n\t        var keepRecordsRegExp=/^$/;\n\t        if (options.keepRecordsRegExp) keepRecordsRegExp=options.keepRecordsRegExp;\n\t\n\t        var start = new Date();\n\t\n\t        var ntuples = {},\n\t            ldr,\n\t            dataLabel,\n\t            dataValue,\n\t            ldrs,\n\t            i, ii, position, endLine, infos;\n\t\n\t        var result = {};\n\t        result.profiling = [];\n\t        result.logs = [];\n\t        var spectra = [];\n\t        result.spectra = spectra;\n\t        result.info = {};\n\t        var spectrum = {};\n\t\n\t        if (!(typeof jcamp === 'string')) return result;\n\t        // console.time('start');\n\t\n\t        if (result.profiling) result.profiling.push({action: 'Before split to LDRS', time: new Date() - start});\n\t\n\t        ldrs = jcamp.split(/[\\r\\n]+##/);\n\t\n\t        if (result.profiling) result.profiling.push({action: 'Split to LDRS', time: new Date() - start});\n\t\n\t        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\t\n\t        for (i = 0, ii = ldrs.length; i < ii; i++) {\n\t            ldr = ldrs[i];\n\t            // This is a new LDR\n\t            position = ldr.indexOf('=');\n\t            if (position > 0) {\n\t                dataLabel = ldr.substring(0, position);\n\t                dataValue = ldr.substring(position + 1).trim();\n\t            } else {\n\t                dataLabel = ldr;\n\t                dataValue = '';\n\t            }\n\t            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\t\n\t            if (dataLabel === 'DATATABLE') {\n\t                endLine = dataValue.indexOf('\\n');\n\t                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n\t                if (endLine > 0) {\n\t                    var xIndex = -1;\n\t                    var yIndex = -1;\n\t                    // ##DATA TABLE= (X++(I..I)), XYDATA\n\t                    // We need to find the variables\n\t\n\t                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n\t                    if (infos[0].indexOf('++') > 0) {\n\t                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n\t                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n\t                        xIndex = ntuples.symbol.indexOf(firstVariable);\n\t                        yIndex = ntuples.symbol.indexOf(secondVariable);\n\t                    }\n\t\n\t                    if (xIndex === -1) xIndex = 0;\n\t                    if (yIndex === -1) yIndex = 0;\n\t\n\t                    if (ntuples.first) {\n\t                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n\t                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n\t                    }\n\t                    if (ntuples.last) {\n\t                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n\t                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n\t                    }\n\t                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n\t                        spectrum.nbPoints = ntuples.vardim[xIndex];\n\t                    }\n\t                    if (ntuples.factor) {\n\t                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n\t                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n\t                    }\n\t                    if (ntuples.units) {\n\t                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n\t                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n\t                    }\n\t                    spectrum.datatable = infos[0];\n\t                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n\t                        dataLabel = 'PEAKTABLE';\n\t                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n\t                        dataLabel = 'XYDATA';\n\t                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t                    }\n\t                }\n\t            }\n\t\n\t\n\t            if (dataLabel === 'TITLE') {\n\t                spectrum.title = dataValue;\n\t            } else if (dataLabel === 'DATATYPE') {\n\t                spectrum.dataType = dataValue;\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'NTUPLES') {\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'XUNITS') {\n\t                spectrum.xUnit = dataValue;\n\t            } else if (dataLabel === 'YUNITS') {\n\t                spectrum.yUnit = dataValue;\n\t            } else if (dataLabel === 'FIRSTX') {\n\t                spectrum.firstX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTX') {\n\t                spectrum.lastX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'FIRSTY') {\n\t                spectrum.firstY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTY') {\n\t                spectrum.lastY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'NPOINTS') {\n\t                spectrum.nbPoints = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XFACTOR') {\n\t                spectrum.xFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'YFACTOR') {\n\t                spectrum.yFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'DELTAX') {\n\t                spectrum.deltaX = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n\t                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVENUCLEUS') {\n\t                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n\t            } else if (dataLabel === '$SFO2') {\n\t                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\t\n\t            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n\t                result.shiftOffsetNum = 0;\n\t                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n\t            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\t\n\t\n\t                // if we activate this part it does not work for ACD specmanager\n\t                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n\t                //                 var parts = dataValue.split(/ *, */);\n\t                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n\t                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n\t            } else if (dataLabel === 'VARNAME') {\n\t                ntuples.varname = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'SYMBOL') {\n\t                ntuples.symbol = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARTYPE') {\n\t                ntuples.vartype = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARFORM') {\n\t                ntuples.varform = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARDIM') {\n\t                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'UNITS') {\n\t                ntuples.units = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'FACTOR') {\n\t                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'FIRST') {\n\t                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'LAST') {\n\t                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'MIN') {\n\t                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'MAX') {\n\t                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === '.NUCLEUS') {\n\t                if (result.twoD) {\n\t                    result.yType = dataValue.split(ntuplesSeparator)[0];\n\t                }\n\t            } else if (dataLabel === 'PAGE') {\n\t                spectrum.page = dataValue.trim();\n\t                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n\t                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n\t                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n\t                var unit = '';\n\t                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n\t                    unit = ntuples.units[pageSymbolIndex];\n\t                }\n\t                if (result.indirectFrequency && unit !== 'PPM') {\n\t                    spectrum.pageValue /= result.indirectFrequency;\n\t                }\n\t            } else if (dataLabel === 'RETENTIONTIME') {\n\t                spectrum.pageValue = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XYDATA') {\n\t                prepareSpectrum(result, spectrum);\n\t                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n\t                if (dataValue.match(/.*\\+\\+.*/)) {\n\t                    if (options.fastParse===false) {\n\t                        parseXYDataRegExp(spectrum, dataValue, result);\n\t                    } else {\n\t                        fastParseXYData(spectrum, dataValue, result);\n\t                    }\n\t                } else {\n\t                    parsePeakTable(spectrum, dataValue, result);\n\t                }\n\t                spectra.push(spectrum);\n\t                spectrum = {};\n\t            } else if (dataLabel === 'PEAKTABLE') {\n\t                prepareSpectrum(result, spectrum);\n\t                parsePeakTable(spectrum, dataValue, result);\n\t                spectra.push(spectrum);\n\t                spectrum = {};\n\t            } else if (isMSField(dataLabel)) {\n\t                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n\t            }\n\t            if (dataLabel.match(keepRecordsRegExp)) {\n\t                result.info[dataLabel] = dataValue.trim();\n\t            }\n\t        }\n\t\n\t        // Currently disabled\n\t        //    if (options && options.lowRes) addLowRes(spectra,options);\n\t\n\t        if (result.profiling) result.profiling.push({action: 'Finished parsing', time: new Date() - start});\n\t\n\t        if (Object.keys(ntuples).length>0) {\n\t            var newNtuples=[];\n\t            var keys=Object.keys(ntuples);\n\t            for (var i=0; i<keys.length; i++) {\n\t                var key=keys[i];\n\t                var values=ntuples[key];\n\t                for (var j=0; j<values.length; j++) {\n\t                    if (! newNtuples[j]) newNtuples[j]={};\n\t                    newNtuples[j][key]=values[j];\n\t                }\n\t            }\n\t            result.ntuples=newNtuples;\n\t        }\n\t\n\t        if (result.twoD) {\n\t            add2D(result);\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished countour plot calculation',\n\t                time: new Date() - start\n\t            });\n\t            if (!options.keepSpectra) {\n\t                delete result.spectra;\n\t            }\n\t        }\n\t\n\t        var isGCMS = (spectra.length > 1 && (! spectra[0].dataType || spectra[0].dataType.match(/.*mass.*/i)));\n\t        if (isGCMS && options.newGCMS) {\n\t            options.xy = true;\n\t        }\n\t\n\t        if (options.xy) { // the spectraData should not be a oneD array but an object with x and y\n\t            if (spectra.length > 0) {\n\t                for (var i=0; i<spectra.length; i++) {\n\t                    var spectrum=spectra[i];\n\t                    if (spectrum.data.length>0) {\n\t                        for (var j=0; j<spectrum.data.length; j++) {\n\t                            var data=spectrum.data[j];\n\t                            var newData={x: new Array(data.length/2), y:new Array(data.length/2)};\n\t                            for (var k=0; k<data.length; k=k+2) {\n\t                                newData.x[k/2]=data[k];\n\t                                newData.y[k/2]=data[k+1];\n\t                            }\n\t                            spectrum.data[j]=newData;\n\t                        }\n\t\n\t                    }\n\t\n\t                }\n\t            }\n\t        }\n\t\n\t        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n\t        if (isGCMS) {\n\t            if (options.newGCMS) {\n\t                addNewGCMS(result);\n\t            } else {\n\t                addGCMS(result);\n\t            }\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished GCMS calculation',\n\t                time: new Date() - start\n\t            });\n\t        }\n\t\n\t        if (result.profiling) {\n\t            result.profiling.push({action: 'Total time', time: new Date() - start});\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t\n\t    function convertMSFieldToLabel(value) {\n\t        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n\t    }\n\t\n\t    function isMSField(dataLabel) {\n\t        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n\t    }\n\t\n\t    function addNewGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var length  = spectra.length;\n\t        var gcms = {\n\t            times: new Array(length),\n\t            series: [{\n\t                name: 'ms',\n\t                dimension: 2,\n\t                data: new Array(length)\n\t            }]\n\t        };\n\t\n\t        var i;\n\t        var existingGCMSFields = [];\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t                gcms.series.push({\n\t                    name: label,\n\t                    dimension: 1,\n\t                    data: new Array(length)\n\t                });\n\t            }\n\t        }\n\t\n\t        for (i = 0; i < length; i++) {\n\t            var spectrum = spectra[i];\n\t            gcms.times[i] = spectrum.pageValue;\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.series[j + 1].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n\t            }\n\t            if (spectrum.data) {\n\t                gcms.series[0].data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n\t            }\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function addGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var existingGCMSFields = [];\n\t        var i;\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t            }\n\t        }\n\t        if (existingGCMSFields.length===0) return;\n\t        var gcms = {};\n\t        gcms.gc = {};\n\t        gcms.ms = [];\n\t        for (i = 0; i < existingGCMSFields.length; i++) {\n\t            gcms.gc[existingGCMSFields[i]] = [];\n\t        }\n\t        for (i = 0; i < spectra.length; i++) {\n\t            var spectrum = spectra[i];\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n\t                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n\t            }\n\t          if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function prepareSpectrum(result, spectrum) {\n\t        if (!spectrum.xFactor) spectrum.xFactor = 1;\n\t        if (!spectrum.yFactor) spectrum.yFactor = 1;\n\t        if (spectrum.observeFrequency) {\n\t            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n\t                spectrum.xUnit = 'PPM';\n\t                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n\t                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n\t                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n\t                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n\t            }\n\t        }\n\t        if (result.shiftOffsetVal) {\n\t            var shift = spectrum.firstX - result.shiftOffsetVal;\n\t            spectrum.firstX = spectrum.firstX - shift;\n\t            spectrum.lastX = spectrum.lastX - shift;\n\t        }\n\t    }\n\t\n\t\n\t\n\t    function convertTo3DZ(spectra) {\n\t        var noise = 0;\n\t        var minZ = spectra[0].data[0][0];\n\t        var maxZ = minZ;\n\t        var ySize = spectra.length;\n\t        var xSize = spectra[0].data[0].length / 2;\n\t        var z = new Array(ySize);\n\t        for (var i = 0; i < ySize; i++) {\n\t            z[i] = new Array(xSize);\n\t            for (var j = 0; j < xSize; j++) {\n\t                z[i][j] = spectra[i].data[0][j * 2 + 1];\n\t                if (z[i][j] < minZ) minZ = spectra[i].data[0][j * 2 + 1];\n\t                if (z[i][j] > maxZ) maxZ = spectra[i].data[0][j * 2 + 1];\n\t                if (i !== 0 && j !== 0) {\n\t                    noise += Math.abs(z[i][j] - z[i][j - 1]) + Math.abs(z[i][j] - z[i - 1][j]);\n\t                }\n\t            }\n\t        }\n\t        return {\n\t            z: z,\n\t            minX: spectra[0].data[0][0],\n\t            maxX: spectra[0].data[0][spectra[0].data[0].length - 2],\n\t            minY: spectra[0].pageValue,\n\t            maxY: spectra[ySize - 1].pageValue,\n\t            minZ: minZ,\n\t            maxZ: maxZ,\n\t            noise: noise / ((ySize - 1) * (xSize - 1) * 2)\n\t        };\n\t\n\t    }\n\t\n\t    function add2D(result) {\n\t        var zData = convertTo3DZ(result.spectra);\n\t        result.contourLines = generateContourLines(zData);\n\t        delete zData.z;\n\t        result.minMax = zData;\n\t    }\n\t\n\t\n\t    function generateContourLines(zData, options) {\n\t        // console.time('generateContourLines');\n\t        var noise = zData.noise;\n\t        var z = zData.z;\n\t        var contourLevels = [];\n\t        var nbLevels = 7;\n\t        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n\t        var isOver0, isOver1, isOver2, isOver3;\n\t        var nbSubSpectra = z.length;\n\t        var nbPovars = z[0].length;\n\t        var pAx, pAy, pBx, pBy;\n\t\n\t        var x0 = zData.minX;\n\t        var xN = zData.maxX;\n\t        var dx = (xN - x0) / (nbPovars - 1);\n\t        var y0 = zData.minY;\n\t        var yN = zData.maxY;\n\t        var dy = (yN - y0) / (nbSubSpectra - 1);\n\t        var minZ = zData.minZ;\n\t        var maxZ = zData.maxZ;\n\t\n\t        //System.out.prvarln('y0 '+y0+' yN '+yN);\n\t        // -------------------------\n\t        // Povars attribution\n\t        //\n\t        // 0----1\n\t        // |  / |\n\t        // | /  |\n\t        // 2----3\n\t        //\n\t        // ---------------------d------\n\t\n\t        var lineZValue;\n\t        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n\t            var contourLevel = {};\n\t            contourLevels[level]=contourLevel;\n\t            var side = level % 2;\n\t            if (side === 0) {\n\t                lineZValue = (maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) + 5 * noise;\n\t            } else {\n\t                lineZValue = -(maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) - 5 * noise;\n\t            }\n\t            var lines = [];\n\t            contourLevel.zValue = lineZValue;\n\t            contourLevel.lines = lines;\n\t\n\t            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\t\n\t            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n\t                for (var povar = 0; povar < nbPovars - 1; povar++) {\n\t                    povarHeight0 = z[iSubSpectra][povar];\n\t                    povarHeight1 = z[iSubSpectra][povar + 1];\n\t                    povarHeight2 = z[(iSubSpectra + 1)][povar];\n\t                    povarHeight3 = z[(iSubSpectra + 1)][(povar + 1)];\n\t\n\t\n\t                    isOver0 = (povarHeight0 > lineZValue);\n\t                    isOver1 = (povarHeight1 > lineZValue);\n\t                    isOver2 = (povarHeight2 > lineZValue);\n\t                    isOver3 = (povarHeight3 > lineZValue);\n\t\n\t                    \n\t                    // Example povar0 is over the plane and povar1 and\n\t                    // povar2 are below, we find the varersections and add\n\t                    // the segment\n\t                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n\t                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n\t                        pAy = iSubSpectra;\n\t                        pBx = povar;\n\t                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n\t                        lines.push(pAx * dx + x0); lines.push(pAy * dy + y0); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                    }\n\t                    // remove push does not help !!!!\n\t                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n\t                        pAx = povar + 1;\n\t                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n\t                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n\t                        pBy = iSubSpectra + 1;\n\t                        lines.push(pAx * dx + x0); lines.push(pAy * dy + y0); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                    }\n\t                    // test around the diagonal\n\t                    if (isOver1 !== isOver2) {\n\t                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n\t                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n\t                        if (isOver1 !== isOver0) {\n\t                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n\t                            pBy = iSubSpectra;\n\t                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver2 !== isOver0) {\n\t                            pBx = povar;\n\t                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n\t                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver1 !== isOver3) {\n\t                            pBx = povar + 1;\n\t                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n\t                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver2 !== isOver3) {\n\t                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n\t                            pBy = iSubSpectra + 1;\n\t                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        // console.timeEnd('generateContourLines');\n\t        return {\n\t            minX: zData.minX,\n\t            maxX: zData.maxX,\n\t            minY: zData.minY,\n\t            maxY: zData.maxY,\n\t            segments: contourLevels\n\t        };\n\t        //return contourLevels;\n\t    }\n\t\n\t\n\t    function addLowRes(spectra, options) {\n\t        var spectrum;\n\t        var averageX, averageY;\n\t        var targetNbPoints = options.lowRes;\n\t        var highResData;\n\t        for (var i = 0; i < spectra.length; i++) {\n\t            spectrum = spectra[i];\n\t            // we need to find the current higher resolution\n\t            if (spectrum.data.length > 0) {\n\t                highResData = spectrum.data[0];\n\t                for (var j = 1; j < spectrum.data.length; j++) {\n\t                    if (spectrum.data[j].length > highResData.length) {\n\t                        highResData = spectrum.data[j];\n\t                    }\n\t                }\n\t\n\t                if (targetNbPoints > (highResData.length / 2)) return;\n\t                var i, ii;\n\t                var lowResData = [];\n\t                var modulo = Math.ceil(highResData.length / (targetNbPoints * 2));\n\t                for (i = 0, ii = highResData.length; i < ii; i = i + 2) {\n\t                    if (i % modulo === 0) {\n\t                        lowResData.push(highResData[i], highResData[i + 1])\n\t                    }\n\t                }\n\t                spectrum.data.push(lowResData);\n\t            }\n\t        }\n\t    }\n\t\n\t    function fastParseXYData(spectrum, value, result) {\n\t        // TODO need to deal with result\n\t        //  console.log(value);\n\t        // we check if deltaX is defined otherwise we calculate it\n\t        if (!spectrum.deltaX) {\n\t            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t        }\n\t        spectrum.isXYdata = true;\n\t        // TODO to be improved using 2 array {x:[], y:[]}\n\t        var currentData = [];\n\t        var currentPosition = 0;\n\t        spectrum.data = [currentData];\n\t\n\t\n\t        var currentX = spectrum.firstX;\n\t        var currentY = spectrum.firstY;\n\t\n\t        // we skip the first line\n\t        //\n\t        var endLine = false;\n\t        for (var i = 0; i < value.length; i++) {\n\t            var ascii = value.charCodeAt(i);\n\t            if (ascii === 13 || ascii === 10) {\n\t                endLine = true;\n\t            } else {\n\t                if (endLine) break;\n\t            }\n\t        }\n\t\n\t        // we proceed taking the i after the first line\n\t        var newLine = true;\n\t        var isDifference=false;\n\t        var isLastDifference=false;\n\t        var lastDifference=0;\n\t        var isDuplicate=false;\n\t        var inComment = false;\n\t        var currentValue = 0;\n\t        var isNegative = false;\n\t        var inValue=false;\n\t        var skipFirstValue=false;\n\t        var decimalPosition = 0;\n\t        var ascii;\n\t        for (; i <= value.length; i++) {\n\t            if (i===value.length) ascii=13;\n\t            else ascii = value.charCodeAt(i);\n\t            if (inComment) {\n\t                // we should ignore the text if we are after $$\n\t                if (ascii === 13 || ascii === 10) {\n\t                    newLine = true;\n\t                    inComment = false;\n\t                }\n\t            } else {\n\t                // when is it a new value ?\n\t                // when it is not a digit, . or comma\n\t                // it is a number that is either new or we continue\n\t                if ( ascii <= 57 && ascii >= 48) { // a number\n\t                    inValue=true;\n\t                    if (decimalPosition > 0) {\n\t                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n\t                    } else {\n\t                        currentValue *= 10;\n\t                        currentValue += ascii - 48;\n\t                    }\n\t                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n\t                    inValue=true;\n\t                    decimalPosition++;\n\t                } else {\n\t                    if (inValue) {\n\t                        // need to process the previous value\n\t                        if (newLine) {\n\t                            newLine = false; // we don't check the X value\n\t                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n\t                            // if new line and lastDifference, the first value is just a check !\n\t                            // that we don't check ...\n\t                            if (isLastDifference) skipFirstValue=true;\n\t                        } else {\n\t                            // need to deal with duplicate and differences\n\t                            if (skipFirstValue) {\n\t                                skipFirstValue=false;\n\t                            } else {\n\t                                if (isDifference) {\n\t                                    lastDifference=isNegative ? -currentValue : currentValue;\n\t                                    isLastDifference=true;\n\t                                    isDifference=false;\n\t                                }\n\t                                var duplicate=isDuplicate ? currentValue - 1 : 1;\n\t                                for (var j=0; j<duplicate; j++) {\n\t                                    if (isLastDifference) {\n\t                                        currentY += lastDifference;\n\t                                    } else {\n\t                                        currentY = isNegative ? -currentValue : currentValue;\n\t                                    }\n\t\n\t                                    //  console.log(\"Separator\",isNegative ?\n\t                                    //          -currentValue : currentValue,\n\t                                    //      \"isDiff\", isDifference, \"isDup\", isDuplicate,\n\t                                    //      \"lastDif\", lastDifference, \"dup:\", duplicate, \"y\", currentY);\n\t\n\t                                    // push is slightly slower ... (we loose 10%)\n\t                                    currentData[currentPosition++]=currentX;\n\t                                    currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                                    currentX += spectrum.deltaX;\n\t                                }\n\t                            }\n\t                        }\n\t                        isNegative=false;\n\t                        currentValue=0;\n\t                        decimalPosition=0;\n\t                        inValue=false;\n\t                        isDuplicate=false;\n\t                    }\n\t\n\t                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                    if ((ascii < 74) && (ascii > 63)) {\n\t                        inValue=true;\n\t                        isLastDifference=false;\n\t                        currentValue=ascii-64;\n\t                    } else\n\t                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                    if ((ascii > 96) && (ascii < 106)) {\n\t                        inValue=true;\n\t                        isLastDifference=false;\n\t                        currentValue=ascii-96;\n\t                        isNegative=true;\n\t                    } else\n\t                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                    if (ascii===115) {\n\t                        inValue=true;\n\t                        isDuplicate=true;\n\t                        currentValue=9;\n\t                    } else if ((ascii > 82) && (ascii < 91)) {\n\t                        inValue=true;\n\t                        isDuplicate=true;\n\t                        currentValue=ascii-82;\n\t                    } else\n\t                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                    if ((ascii > 73) && (ascii < 83)) {\n\t                        inValue=true;\n\t                        isDifference=true;\n\t                        currentValue=ascii-73;\n\t                    } else\n\t                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                    if ((ascii > 105) && (ascii < 115)) {\n\t                        inValue=true;\n\t                        isDifference=true;\n\t                        currentValue=ascii-105;\n\t                        isNegative=true;\n\t                    } else\n\t                    // $ sign, we need to check the next one\n\t                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n\t                        inValue=true;\n\t                        inComment = true;\n\t                    } else\n\t                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                    if (ascii === 37) {\n\t                        inValue=true;\n\t                        isDifference=true;\n\t                        currentValue=0;\n\t                        isNegative=false;\n\t                    } else\n\t                    if (ascii === 45) { // a \"-\"\n\t                        // check if after there is a number, decimal or comma\n\t                        var ascii2=value.charCodeAt(i+1);\n\t                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n\t                            inValue=true;\n\t                            isLastDifference=false;\n\t                            isNegative = true;\n\t                        }\n\t                    } else if (ascii === 13 || ascii === 10) {\n\t                        newLine = true;\n\t                        inComment = false;\n\t                    }\n\t                    // and now analyse the details ... space or tabulation\n\t                    // if \"+\" we just don't care\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function parsePeakTable(spectrum, value, result) {\n\t        var removeCommentRegExp = /\\$\\$.*/;\n\t        var peakTableSplitRegExp = /[,\\t ]+/;\n\t        \n\t        spectrum.isPeaktable=true;\n\t        var i, ii, j, jj, values;\n\t        var currentData = [];\n\t        spectrum.data = [currentData];\n\t\n\t        // counts for around 20% of the time\n\t        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\t\n\t        var k = 0;\n\t        for (i = 1, ii = lines.length; i < ii; i++) {\n\t            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n\t            if (values.length % 2 === 0) {\n\t                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n\t                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n\t                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n\t                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n\t                }\n\t            } else {\n\t                result.logs.push('Format error: ' + values);\n\t            }\n\t        }\n\t    }\n\t\n\t\n\t\n\t    return convert;\n\t\n\t}\n\t\n\tvar convert = getConverter();\n\t\n\tfunction JcampConverter(input, options, useWorker) {\n\t    if (typeof options === 'boolean') {\n\t        useWorker = options;\n\t        options = {};\n\t    }\n\t    if (useWorker) {\n\t        return postToWorker(input, options);\n\t    } else {\n\t        return convert(input, options);\n\t    }\n\t}\n\t\n\tvar stamps = {},\n\t    worker;\n\t\n\tfunction postToWorker(input, options) {\n\t    if (!worker) {\n\t        createWorker();\n\t    }\n\t    return new Promise(function (resolve) {\n\t        var stamp = Date.now() + '' + Math.random();\n\t        stamps[stamp] = resolve;\n\t        worker.postMessage({stamp: stamp, input: input, options: options});\n\t    });\n\t}\n\t\n\tfunction createWorker() {\n\t    var workerURL = URL.createObjectURL(new Blob([\n\t        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { postMessage({stamp: event.data.stamp, output: convert(event.data.input, event.data.options)}); };'\n\t    ], {type: 'application/javascript'}));\n\t    worker = new Worker(workerURL);\n\t    URL.revokeObjectURL(workerURL);\n\t    worker.addEventListener('message', function (event) {\n\t        var stamp = event.data.stamp;\n\t        if (stamps[stamp]) {\n\t            stamps[stamp](event.data.output);\n\t        }\n\t    });\n\t}\n\t\n\tmodule.exports = {\n\t    convert: JcampConverter\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\tvar xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\n\tvar removeCommentRegExp = /\\$\\$.*/;\n\tvar DEBUG=false;\n\t\n\tmodule.exports=function(spectrum, value, result) {\n\t    // we check if deltaX is defined otherwise we calculate it\n\t    if (!spectrum.deltaX) {\n\t        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t    }\n\t\n\t    spectrum.isXYdata=true;\n\t\n\t    var currentData = [];\n\t    var currentPosition=0;\n\t    spectrum.data = [currentData];\n\t\n\t    var currentX = spectrum.firstX;\n\t    var currentY = spectrum.firstY;\n\t    var lines = value.split(/[\\r\\n]+/);\n\t    var lastDif, values, ascii, expectedY;\n\t    values = [];\n\t    for (var i = 1, ii = lines.length; i < ii; i++) {\n\t        //var previousValues=JSON.parse(JSON.stringify(values));\n\t        values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n\t        if (values.length > 0) {\n\t            if (DEBUG) {\n\t                if (!spectrum.firstPoint) {\n\t                    spectrum.firstPoint = +values[0];\n\t                }\n\t                var expectedCurrentX = (values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n\t                if ((lastDif || lastDif === 0)) {\n\t                    expectedCurrentX += spectrum.deltaX;\n\t                }\n\t                result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n\t            }\n\t            for (var j = 1, jj = values.length; j < jj; j++) {\n\t                if (j === 1 && (lastDif || lastDif === 0)) {\n\t                    lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n\t                    // we could check if we have the expected Y value\n\t                    ascii = values[j].charCodeAt(0);\n\t\n\t                    if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n\t                        // + - . 0 1 2 3 4 5 6 7 8 9\n\t                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                            expectedY = +values[j];\n\t                        } else\n\t                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                        if ((ascii > 63) && (ascii < 74)) {\n\t                            expectedY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                        } else\n\t                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                        if ((ascii > 96) && (ascii < 106)) {\n\t                            expectedY = -(String.fromCharCode(ascii - 48) + values[j].substring(1));\n\t                        }\n\t                        if (expectedY !== currentY) {\n\t                            result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n\t                            result.logs.push('Previous values: ' + previousValues.length);\n\t                            result.logs.push(previousValues);\n\t                        }\n\t                    }\n\t                } else {\n\t                    if (values[j].length > 0) {\n\t                        ascii = values[j].charCodeAt(0);\n\t                        // + - . 0 1 2 3 4 5 6 7 8 9\n\t                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                            lastDif = null;\n\t                            currentY = +values[j];\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                        if ((ascii > 63) && (ascii < 74)) {\n\t                            lastDif = null;\n\t                            currentY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++] = currentX;\n\t                            currentData[currentPosition++] = currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                        if ((ascii > 96) && (ascii < 106)) {\n\t                            lastDif = null;\n\t                            // we can multiply the string by 1 because if may not contain decimal (is this correct ????)\n\t                            currentY = -(String.fromCharCode(ascii - 48) + values[j].substring(1))*1;\n\t                            //currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t\n\t\n\t\n\t                        // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                        if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n\t                            var dup = (String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n\t                            if (ascii === 115) {\n\t                                dup = ('9' + values[j].substring(1)) - 1;\n\t                            }\n\t                            for (var l = 0; l < dup; l++) {\n\t                                if (lastDif) {\n\t                                    currentY = currentY + lastDif;\n\t                                }\n\t                                // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                                currentData[currentPosition++]=currentX;\n\t                                currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                                currentX += spectrum.deltaX;\n\t                            }\n\t                        } else\n\t                        // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                        if (ascii === 37) {\n\t                            lastDif = +('0' + values[j].substring(1));\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else if ((ascii > 73) && (ascii < 83)) {\n\t                            lastDif = (String.fromCharCode(ascii - 25) + values[j].substring(1))*1;\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                        if ((ascii > 105) && (ascii < 115)) {\n\t                            lastDif = -(String.fromCharCode(ascii - 57) + values[j].substring(1))*1;\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** jcampconverter.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 31c0ce823b044a152453\n **/","'use strict';\n\nvar parseXYDataRegExp=require('./parseXYData.js');\n\n\nfunction getConverter() {\n\n    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n    var ntuplesSeparator = /[, \\t]{1,}/;\n\n    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\n    function convertToFloatArray(stringArray) {\n        var l = stringArray.length;\n        var floatArray = new Array(l);\n        for (var i = 0; i < l; i++) {\n            floatArray[i] = parseFloat(stringArray[i]);\n        }\n        return floatArray;\n    }\n\n    /*\n     options.keepSpectra: keep the original spectra for a 2D\n     options.xy: true // create x / y array instead of a 1D array\n     options.keepRecordsRegExp: which fields do we keep\n     */\n\n    function convert(jcamp, options) {\n        options = options || {};\n\n        var keepRecordsRegExp=/^$/;\n        if (options.keepRecordsRegExp) keepRecordsRegExp=options.keepRecordsRegExp;\n\n        var start = new Date();\n\n        var ntuples = {},\n            ldr,\n            dataLabel,\n            dataValue,\n            ldrs,\n            i, ii, position, endLine, infos;\n\n        var result = {};\n        result.profiling = [];\n        result.logs = [];\n        var spectra = [];\n        result.spectra = spectra;\n        result.info = {};\n        var spectrum = {};\n\n        if (!(typeof jcamp === 'string')) return result;\n        // console.time('start');\n\n        if (result.profiling) result.profiling.push({action: 'Before split to LDRS', time: new Date() - start});\n\n        ldrs = jcamp.split(/[\\r\\n]+##/);\n\n        if (result.profiling) result.profiling.push({action: 'Split to LDRS', time: new Date() - start});\n\n        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n        for (i = 0, ii = ldrs.length; i < ii; i++) {\n            ldr = ldrs[i];\n            // This is a new LDR\n            position = ldr.indexOf('=');\n            if (position > 0) {\n                dataLabel = ldr.substring(0, position);\n                dataValue = ldr.substring(position + 1).trim();\n            } else {\n                dataLabel = ldr;\n                dataValue = '';\n            }\n            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n            if (dataLabel === 'DATATABLE') {\n                endLine = dataValue.indexOf('\\n');\n                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n                if (endLine > 0) {\n                    var xIndex = -1;\n                    var yIndex = -1;\n                    // ##DATA TABLE= (X++(I..I)), XYDATA\n                    // We need to find the variables\n\n                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n                    if (infos[0].indexOf('++') > 0) {\n                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n                        xIndex = ntuples.symbol.indexOf(firstVariable);\n                        yIndex = ntuples.symbol.indexOf(secondVariable);\n                    }\n\n                    if (xIndex === -1) xIndex = 0;\n                    if (yIndex === -1) yIndex = 0;\n\n                    if (ntuples.first) {\n                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n                    }\n                    if (ntuples.last) {\n                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n                    }\n                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n                        spectrum.nbPoints = ntuples.vardim[xIndex];\n                    }\n                    if (ntuples.factor) {\n                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n                    }\n                    if (ntuples.units) {\n                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n                    }\n                    spectrum.datatable = infos[0];\n                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n                        dataLabel = 'PEAKTABLE';\n                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n                        dataLabel = 'XYDATA';\n                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                    }\n                }\n            }\n\n\n            if (dataLabel === 'TITLE') {\n                spectrum.title = dataValue;\n            } else if (dataLabel === 'DATATYPE') {\n                spectrum.dataType = dataValue;\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'NTUPLES') {\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'XUNITS') {\n                spectrum.xUnit = dataValue;\n            } else if (dataLabel === 'YUNITS') {\n                spectrum.yUnit = dataValue;\n            } else if (dataLabel === 'FIRSTX') {\n                spectrum.firstX = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTX') {\n                spectrum.lastX = parseFloat(dataValue);\n            } else if (dataLabel === 'FIRSTY') {\n                spectrum.firstY = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTY') {\n                spectrum.lastY = parseFloat(dataValue);\n            } else if (dataLabel === 'NPOINTS') {\n                spectrum.nbPoints = parseFloat(dataValue);\n            } else if (dataLabel === 'XFACTOR') {\n                spectrum.xFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'YFACTOR') {\n                spectrum.yFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'DELTAX') {\n                spectrum.deltaX = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVENUCLEUS') {\n                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n            } else if (dataLabel === '$SFO2') {\n                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\n            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n                result.shiftOffsetNum = 0;\n                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\n\n                // if we activate this part it does not work for ACD specmanager\n                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n                //                 var parts = dataValue.split(/ *, */);\n                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n            } else if (dataLabel === 'VARNAME') {\n                ntuples.varname = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'SYMBOL') {\n                ntuples.symbol = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARTYPE') {\n                ntuples.vartype = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARFORM') {\n                ntuples.varform = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARDIM') {\n                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'UNITS') {\n                ntuples.units = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'FACTOR') {\n                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'FIRST') {\n                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'LAST') {\n                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MIN') {\n                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MAX') {\n                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === '.NUCLEUS') {\n                if (result.twoD) {\n                    result.yType = dataValue.split(ntuplesSeparator)[0];\n                }\n            } else if (dataLabel === 'PAGE') {\n                spectrum.page = dataValue.trim();\n                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n                var unit = '';\n                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n                    unit = ntuples.units[pageSymbolIndex];\n                }\n                if (result.indirectFrequency && unit !== 'PPM') {\n                    spectrum.pageValue /= result.indirectFrequency;\n                }\n            } else if (dataLabel === 'RETENTIONTIME') {\n                spectrum.pageValue = parseFloat(dataValue);\n            } else if (dataLabel === 'XYDATA') {\n                prepareSpectrum(result, spectrum);\n                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n                if (dataValue.match(/.*\\+\\+.*/)) {\n                    if (options.fastParse===false) {\n                        parseXYDataRegExp(spectrum, dataValue, result);\n                    } else {\n                        fastParseXYData(spectrum, dataValue, result);\n                    }\n                } else {\n                    parsePeakTable(spectrum, dataValue, result);\n                }\n                spectra.push(spectrum);\n                spectrum = {};\n            } else if (dataLabel === 'PEAKTABLE') {\n                prepareSpectrum(result, spectrum);\n                parsePeakTable(spectrum, dataValue, result);\n                spectra.push(spectrum);\n                spectrum = {};\n            } else if (isMSField(dataLabel)) {\n                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n            }\n            if (dataLabel.match(keepRecordsRegExp)) {\n                result.info[dataLabel] = dataValue.trim();\n            }\n        }\n\n        // Currently disabled\n        //    if (options && options.lowRes) addLowRes(spectra,options);\n\n        if (result.profiling) result.profiling.push({action: 'Finished parsing', time: new Date() - start});\n\n        if (Object.keys(ntuples).length>0) {\n            var newNtuples=[];\n            var keys=Object.keys(ntuples);\n            for (var i=0; i<keys.length; i++) {\n                var key=keys[i];\n                var values=ntuples[key];\n                for (var j=0; j<values.length; j++) {\n                    if (! newNtuples[j]) newNtuples[j]={};\n                    newNtuples[j][key]=values[j];\n                }\n            }\n            result.ntuples=newNtuples;\n        }\n\n        if (result.twoD) {\n            add2D(result);\n            if (result.profiling) result.profiling.push({\n                action: 'Finished countour plot calculation',\n                time: new Date() - start\n            });\n            if (!options.keepSpectra) {\n                delete result.spectra;\n            }\n        }\n\n        var isGCMS = (spectra.length > 1 && (! spectra[0].dataType || spectra[0].dataType.match(/.*mass.*/i)));\n        if (isGCMS && options.newGCMS) {\n            options.xy = true;\n        }\n\n        if (options.xy) { // the spectraData should not be a oneD array but an object with x and y\n            if (spectra.length > 0) {\n                for (var i=0; i<spectra.length; i++) {\n                    var spectrum=spectra[i];\n                    if (spectrum.data.length>0) {\n                        for (var j=0; j<spectrum.data.length; j++) {\n                            var data=spectrum.data[j];\n                            var newData={x: new Array(data.length/2), y:new Array(data.length/2)};\n                            for (var k=0; k<data.length; k=k+2) {\n                                newData.x[k/2]=data[k];\n                                newData.y[k/2]=data[k+1];\n                            }\n                            spectrum.data[j]=newData;\n                        }\n\n                    }\n\n                }\n            }\n        }\n\n        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n        if (isGCMS) {\n            if (options.newGCMS) {\n                addNewGCMS(result);\n            } else {\n                addGCMS(result);\n            }\n            if (result.profiling) result.profiling.push({\n                action: 'Finished GCMS calculation',\n                time: new Date() - start\n            });\n        }\n\n        if (result.profiling) {\n            result.profiling.push({action: 'Total time', time: new Date() - start});\n        }\n\n        return result;\n    }\n\n\n    function convertMSFieldToLabel(value) {\n        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n    }\n\n    function isMSField(dataLabel) {\n        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n    }\n\n    function addNewGCMS(result) {\n        var spectra = result.spectra;\n        var length  = spectra.length;\n        var gcms = {\n            times: new Array(length),\n            series: [{\n                name: 'ms',\n                dimension: 2,\n                data: new Array(length)\n            }]\n        };\n\n        var i;\n        var existingGCMSFields = [];\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n                gcms.series.push({\n                    name: label,\n                    dimension: 1,\n                    data: new Array(length)\n                });\n            }\n        }\n\n        for (i = 0; i < length; i++) {\n            var spectrum = spectra[i];\n            gcms.times[i] = spectrum.pageValue;\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.series[j + 1].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n            }\n            if (spectrum.data) {\n                gcms.series[0].data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n            }\n\n        }\n        result.gcms = gcms;\n    }\n\n    function addGCMS(result) {\n        var spectra = result.spectra;\n        var existingGCMSFields = [];\n        var i;\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n            }\n        }\n        if (existingGCMSFields.length===0) return;\n        var gcms = {};\n        gcms.gc = {};\n        gcms.ms = [];\n        for (i = 0; i < existingGCMSFields.length; i++) {\n            gcms.gc[existingGCMSFields[i]] = [];\n        }\n        for (i = 0; i < spectra.length; i++) {\n            var spectrum = spectra[i];\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n            }\n          if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\n        }\n        result.gcms = gcms;\n    }\n\n    function prepareSpectrum(result, spectrum) {\n        if (!spectrum.xFactor) spectrum.xFactor = 1;\n        if (!spectrum.yFactor) spectrum.yFactor = 1;\n        if (spectrum.observeFrequency) {\n            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n                spectrum.xUnit = 'PPM';\n                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n            }\n        }\n        if (result.shiftOffsetVal) {\n            var shift = spectrum.firstX - result.shiftOffsetVal;\n            spectrum.firstX = spectrum.firstX - shift;\n            spectrum.lastX = spectrum.lastX - shift;\n        }\n    }\n\n\n\n    function convertTo3DZ(spectra) {\n        var noise = 0;\n        var minZ = spectra[0].data[0][0];\n        var maxZ = minZ;\n        var ySize = spectra.length;\n        var xSize = spectra[0].data[0].length / 2;\n        var z = new Array(ySize);\n        for (var i = 0; i < ySize; i++) {\n            z[i] = new Array(xSize);\n            for (var j = 0; j < xSize; j++) {\n                z[i][j] = spectra[i].data[0][j * 2 + 1];\n                if (z[i][j] < minZ) minZ = spectra[i].data[0][j * 2 + 1];\n                if (z[i][j] > maxZ) maxZ = spectra[i].data[0][j * 2 + 1];\n                if (i !== 0 && j !== 0) {\n                    noise += Math.abs(z[i][j] - z[i][j - 1]) + Math.abs(z[i][j] - z[i - 1][j]);\n                }\n            }\n        }\n        return {\n            z: z,\n            minX: spectra[0].data[0][0],\n            maxX: spectra[0].data[0][spectra[0].data[0].length - 2],\n            minY: spectra[0].pageValue,\n            maxY: spectra[ySize - 1].pageValue,\n            minZ: minZ,\n            maxZ: maxZ,\n            noise: noise / ((ySize - 1) * (xSize - 1) * 2)\n        };\n\n    }\n\n    function add2D(result) {\n        var zData = convertTo3DZ(result.spectra);\n        result.contourLines = generateContourLines(zData);\n        delete zData.z;\n        result.minMax = zData;\n    }\n\n\n    function generateContourLines(zData, options) {\n        // console.time('generateContourLines');\n        var noise = zData.noise;\n        var z = zData.z;\n        var contourLevels = [];\n        var nbLevels = 7;\n        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n        var isOver0, isOver1, isOver2, isOver3;\n        var nbSubSpectra = z.length;\n        var nbPovars = z[0].length;\n        var pAx, pAy, pBx, pBy;\n\n        var x0 = zData.minX;\n        var xN = zData.maxX;\n        var dx = (xN - x0) / (nbPovars - 1);\n        var y0 = zData.minY;\n        var yN = zData.maxY;\n        var dy = (yN - y0) / (nbSubSpectra - 1);\n        var minZ = zData.minZ;\n        var maxZ = zData.maxZ;\n\n        //System.out.prvarln('y0 '+y0+' yN '+yN);\n        // -------------------------\n        // Povars attribution\n        //\n        // 0----1\n        // |  / |\n        // | /  |\n        // 2----3\n        //\n        // ---------------------d------\n\n        var lineZValue;\n        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n            var contourLevel = {};\n            contourLevels[level]=contourLevel;\n            var side = level % 2;\n            if (side === 0) {\n                lineZValue = (maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) + 5 * noise;\n            } else {\n                lineZValue = -(maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) - 5 * noise;\n            }\n            var lines = [];\n            contourLevel.zValue = lineZValue;\n            contourLevel.lines = lines;\n\n            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n                for (var povar = 0; povar < nbPovars - 1; povar++) {\n                    povarHeight0 = z[iSubSpectra][povar];\n                    povarHeight1 = z[iSubSpectra][povar + 1];\n                    povarHeight2 = z[(iSubSpectra + 1)][povar];\n                    povarHeight3 = z[(iSubSpectra + 1)][(povar + 1)];\n\n\n                    isOver0 = (povarHeight0 > lineZValue);\n                    isOver1 = (povarHeight1 > lineZValue);\n                    isOver2 = (povarHeight2 > lineZValue);\n                    isOver3 = (povarHeight3 > lineZValue);\n\n                    \n                    // Example povar0 is over the plane and povar1 and\n                    // povar2 are below, we find the varersections and add\n                    // the segment\n                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n                        pAy = iSubSpectra;\n                        pBx = povar;\n                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n                        lines.push(pAx * dx + x0); lines.push(pAy * dy + y0); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                    }\n                    // remove push does not help !!!!\n                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n                        pAx = povar + 1;\n                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n                        pBy = iSubSpectra + 1;\n                        lines.push(pAx * dx + x0); lines.push(pAy * dy + y0); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                    }\n                    // test around the diagonal\n                    if (isOver1 !== isOver2) {\n                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n                        if (isOver1 !== isOver0) {\n                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n                            pBy = iSubSpectra;\n                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver0) {\n                            pBx = povar;\n                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                        }\n                        if (isOver1 !== isOver3) {\n                            pBx = povar + 1;\n                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver3) {\n                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n                            pBy = iSubSpectra + 1;\n                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                        }\n                    }\n                }\n            }\n        }\n        // console.timeEnd('generateContourLines');\n        return {\n            minX: zData.minX,\n            maxX: zData.maxX,\n            minY: zData.minY,\n            maxY: zData.maxY,\n            segments: contourLevels\n        };\n        //return contourLevels;\n    }\n\n\n    function addLowRes(spectra, options) {\n        var spectrum;\n        var averageX, averageY;\n        var targetNbPoints = options.lowRes;\n        var highResData;\n        for (var i = 0; i < spectra.length; i++) {\n            spectrum = spectra[i];\n            // we need to find the current higher resolution\n            if (spectrum.data.length > 0) {\n                highResData = spectrum.data[0];\n                for (var j = 1; j < spectrum.data.length; j++) {\n                    if (spectrum.data[j].length > highResData.length) {\n                        highResData = spectrum.data[j];\n                    }\n                }\n\n                if (targetNbPoints > (highResData.length / 2)) return;\n                var i, ii;\n                var lowResData = [];\n                var modulo = Math.ceil(highResData.length / (targetNbPoints * 2));\n                for (i = 0, ii = highResData.length; i < ii; i = i + 2) {\n                    if (i % modulo === 0) {\n                        lowResData.push(highResData[i], highResData[i + 1])\n                    }\n                }\n                spectrum.data.push(lowResData);\n            }\n        }\n    }\n\n    function fastParseXYData(spectrum, value, result) {\n        // TODO need to deal with result\n        //  console.log(value);\n        // we check if deltaX is defined otherwise we calculate it\n        if (!spectrum.deltaX) {\n            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n        }\n        spectrum.isXYdata = true;\n        // TODO to be improved using 2 array {x:[], y:[]}\n        var currentData = [];\n        var currentPosition = 0;\n        spectrum.data = [currentData];\n\n\n        var currentX = spectrum.firstX;\n        var currentY = spectrum.firstY;\n\n        // we skip the first line\n        //\n        var endLine = false;\n        for (var i = 0; i < value.length; i++) {\n            var ascii = value.charCodeAt(i);\n            if (ascii === 13 || ascii === 10) {\n                endLine = true;\n            } else {\n                if (endLine) break;\n            }\n        }\n\n        // we proceed taking the i after the first line\n        var newLine = true;\n        var isDifference=false;\n        var isLastDifference=false;\n        var lastDifference=0;\n        var isDuplicate=false;\n        var inComment = false;\n        var currentValue = 0;\n        var isNegative = false;\n        var inValue=false;\n        var skipFirstValue=false;\n        var decimalPosition = 0;\n        var ascii;\n        for (; i <= value.length; i++) {\n            if (i===value.length) ascii=13;\n            else ascii = value.charCodeAt(i);\n            if (inComment) {\n                // we should ignore the text if we are after $$\n                if (ascii === 13 || ascii === 10) {\n                    newLine = true;\n                    inComment = false;\n                }\n            } else {\n                // when is it a new value ?\n                // when it is not a digit, . or comma\n                // it is a number that is either new or we continue\n                if ( ascii <= 57 && ascii >= 48) { // a number\n                    inValue=true;\n                    if (decimalPosition > 0) {\n                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n                    } else {\n                        currentValue *= 10;\n                        currentValue += ascii - 48;\n                    }\n                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n                    inValue=true;\n                    decimalPosition++;\n                } else {\n                    if (inValue) {\n                        // need to process the previous value\n                        if (newLine) {\n                            newLine = false; // we don't check the X value\n                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n                            // if new line and lastDifference, the first value is just a check !\n                            // that we don't check ...\n                            if (isLastDifference) skipFirstValue=true;\n                        } else {\n                            // need to deal with duplicate and differences\n                            if (skipFirstValue) {\n                                skipFirstValue=false;\n                            } else {\n                                if (isDifference) {\n                                    lastDifference=isNegative ? -currentValue : currentValue;\n                                    isLastDifference=true;\n                                    isDifference=false;\n                                }\n                                var duplicate=isDuplicate ? currentValue - 1 : 1;\n                                for (var j=0; j<duplicate; j++) {\n                                    if (isLastDifference) {\n                                        currentY += lastDifference;\n                                    } else {\n                                        currentY = isNegative ? -currentValue : currentValue;\n                                    }\n\n                                    //  console.log(\"Separator\",isNegative ?\n                                    //          -currentValue : currentValue,\n                                    //      \"isDiff\", isDifference, \"isDup\", isDuplicate,\n                                    //      \"lastDif\", lastDifference, \"dup:\", duplicate, \"y\", currentY);\n\n                                    // push is slightly slower ... (we loose 10%)\n                                    currentData[currentPosition++]=currentX;\n                                    currentData[currentPosition++]=currentY * spectrum.yFactor;\n                                    currentX += spectrum.deltaX;\n                                }\n                            }\n                        }\n                        isNegative=false;\n                        currentValue=0;\n                        decimalPosition=0;\n                        inValue=false;\n                        isDuplicate=false;\n                    }\n\n                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                    if ((ascii < 74) && (ascii > 63)) {\n                        inValue=true;\n                        isLastDifference=false;\n                        currentValue=ascii-64;\n                    } else\n                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                    if ((ascii > 96) && (ascii < 106)) {\n                        inValue=true;\n                        isLastDifference=false;\n                        currentValue=ascii-96;\n                        isNegative=true;\n                    } else\n                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                    if (ascii===115) {\n                        inValue=true;\n                        isDuplicate=true;\n                        currentValue=9;\n                    } else if ((ascii > 82) && (ascii < 91)) {\n                        inValue=true;\n                        isDuplicate=true;\n                        currentValue=ascii-82;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if ((ascii > 73) && (ascii < 83)) {\n                        inValue=true;\n                        isDifference=true;\n                        currentValue=ascii-73;\n                    } else\n                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n                    if ((ascii > 105) && (ascii < 115)) {\n                        inValue=true;\n                        isDifference=true;\n                        currentValue=ascii-105;\n                        isNegative=true;\n                    } else\n                    // $ sign, we need to check the next one\n                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n                        inValue=true;\n                        inComment = true;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if (ascii === 37) {\n                        inValue=true;\n                        isDifference=true;\n                        currentValue=0;\n                        isNegative=false;\n                    } else\n                    if (ascii === 45) { // a \"-\"\n                        // check if after there is a number, decimal or comma\n                        var ascii2=value.charCodeAt(i+1);\n                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n                            inValue=true;\n                            isLastDifference=false;\n                            isNegative = true;\n                        }\n                    } else if (ascii === 13 || ascii === 10) {\n                        newLine = true;\n                        inComment = false;\n                    }\n                    // and now analyse the details ... space or tabulation\n                    // if \"+\" we just don't care\n                }\n            }\n        }\n    }\n\n    function parsePeakTable(spectrum, value, result) {\n        var removeCommentRegExp = /\\$\\$.*/;\n        var peakTableSplitRegExp = /[,\\t ]+/;\n        \n        spectrum.isPeaktable=true;\n        var i, ii, j, jj, values;\n        var currentData = [];\n        spectrum.data = [currentData];\n\n        // counts for around 20% of the time\n        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n        var k = 0;\n        for (i = 1, ii = lines.length; i < ii; i++) {\n            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n            if (values.length % 2 === 0) {\n                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n                }\n            } else {\n                result.logs.push('Format error: ' + values);\n            }\n        }\n    }\n\n\n\n    return convert;\n\n}\n\nvar convert = getConverter();\n\nfunction JcampConverter(input, options, useWorker) {\n    if (typeof options === 'boolean') {\n        useWorker = options;\n        options = {};\n    }\n    if (useWorker) {\n        return postToWorker(input, options);\n    } else {\n        return convert(input, options);\n    }\n}\n\nvar stamps = {},\n    worker;\n\nfunction postToWorker(input, options) {\n    if (!worker) {\n        createWorker();\n    }\n    return new Promise(function (resolve) {\n        var stamp = Date.now() + '' + Math.random();\n        stamps[stamp] = resolve;\n        worker.postMessage({stamp: stamp, input: input, options: options});\n    });\n}\n\nfunction createWorker() {\n    var workerURL = URL.createObjectURL(new Blob([\n        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { postMessage({stamp: event.data.stamp, output: convert(event.data.input, event.data.options)}); };'\n    ], {type: 'application/javascript'}));\n    worker = new Worker(workerURL);\n    URL.revokeObjectURL(workerURL);\n    worker.addEventListener('message', function (event) {\n        var stamp = event.data.stamp;\n        if (stamps[stamp]) {\n            stamps[stamp](event.data.output);\n        }\n    });\n}\n\nmodule.exports = {\n    convert: JcampConverter\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\n\nvar xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\nvar removeCommentRegExp = /\\$\\$.*/;\nvar DEBUG=false;\n\nmodule.exports=function(spectrum, value, result) {\n    // we check if deltaX is defined otherwise we calculate it\n    if (!spectrum.deltaX) {\n        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n    }\n\n    spectrum.isXYdata=true;\n\n    var currentData = [];\n    var currentPosition=0;\n    spectrum.data = [currentData];\n\n    var currentX = spectrum.firstX;\n    var currentY = spectrum.firstY;\n    var lines = value.split(/[\\r\\n]+/);\n    var lastDif, values, ascii, expectedY;\n    values = [];\n    for (var i = 1, ii = lines.length; i < ii; i++) {\n        //var previousValues=JSON.parse(JSON.stringify(values));\n        values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n        if (values.length > 0) {\n            if (DEBUG) {\n                if (!spectrum.firstPoint) {\n                    spectrum.firstPoint = +values[0];\n                }\n                var expectedCurrentX = (values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n                if ((lastDif || lastDif === 0)) {\n                    expectedCurrentX += spectrum.deltaX;\n                }\n                result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n            }\n            for (var j = 1, jj = values.length; j < jj; j++) {\n                if (j === 1 && (lastDif || lastDif === 0)) {\n                    lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n                    // we could check if we have the expected Y value\n                    ascii = values[j].charCodeAt(0);\n\n                    if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n                        // + - . 0 1 2 3 4 5 6 7 8 9\n                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                            expectedY = +values[j];\n                        } else\n                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                        if ((ascii > 63) && (ascii < 74)) {\n                            expectedY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                        } else\n                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                        if ((ascii > 96) && (ascii < 106)) {\n                            expectedY = -(String.fromCharCode(ascii - 48) + values[j].substring(1));\n                        }\n                        if (expectedY !== currentY) {\n                            result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n                            result.logs.push('Previous values: ' + previousValues.length);\n                            result.logs.push(previousValues);\n                        }\n                    }\n                } else {\n                    if (values[j].length > 0) {\n                        ascii = values[j].charCodeAt(0);\n                        // + - . 0 1 2 3 4 5 6 7 8 9\n                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                            lastDif = null;\n                            currentY = +values[j];\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                        if ((ascii > 63) && (ascii < 74)) {\n                            lastDif = null;\n                            currentY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++] = currentX;\n                            currentData[currentPosition++] = currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                        if ((ascii > 96) && (ascii < 106)) {\n                            lastDif = null;\n                            // we can multiply the string by 1 because if may not contain decimal (is this correct ????)\n                            currentY = -(String.fromCharCode(ascii - 48) + values[j].substring(1))*1;\n                            //currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n\n\n\n                        // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                        if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n                            var dup = (String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n                            if (ascii === 115) {\n                                dup = ('9' + values[j].substring(1)) - 1;\n                            }\n                            for (var l = 0; l < dup; l++) {\n                                if (lastDif) {\n                                    currentY = currentY + lastDif;\n                                }\n                                // currentData.push(currentX, currentY * spectrum.yFactor);\n                                currentData[currentPosition++]=currentX;\n                                currentData[currentPosition++]=currentY * spectrum.yFactor;\n                                currentX += spectrum.deltaX;\n                            }\n                        } else\n                        // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                        if (ascii === 37) {\n                            lastDif = +('0' + values[j].substring(1));\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else if ((ascii > 73) && (ascii < 83)) {\n                            lastDif = (String.fromCharCode(ascii - 25) + values[j].substring(1))*1;\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // negative DIF digits j k l m n o p q r (ascii 106-114)\n                        if ((ascii > 105) && (ascii < 115)) {\n                            lastDif = -(String.fromCharCode(ascii - 57) + values[j].substring(1))*1;\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parseXYData.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}