{"version":3,"sources":["webpack:///jcampconverter/webpack/universalModuleDefinition","webpack:///jcampconverter/jcampconverter.min.js","webpack:///jcampconverter/webpack/bootstrap f4c83f47ab05faac88b9","webpack:///jcampconverter/./src/index.js","webpack:///jcampconverter/./src/parseXYData.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","getConverter","convertToFloatArray","stringArray","l","length","floatArray","Array","i","parseFloat","Spectrum","convert","jcamp","options","keepRecordsRegExp","ldr","dataLabel","dataValue","ldrs","ii","position","endLine","infos","wantXY","withoutXY","start","Date","now","ntuples","result","profiling","logs","spectra","info","spectrum","push","action","time","split","replace","indexOf","substring","trim","toUpperCase","xIndex","yIndex","firstVariable","secondVariable","symbol","first","firstX","firstY","last","lastX","lastY","vardim","nbPoints","factor","xFactor","yFactor","units","xUnit","yUnit","datatable","deltaX","title","dataType","twoD","observeFrequency","xType","indirectFrequency","shiftOffsetNum","shiftOffsetVal","varname","ntuplesSeparator","vartype","varform","min","max","yType","page","pageValue","pageSymbol","pageSymbolIndex","unit","isMSField","convertMSFieldToLabel","match","prepareSpectrum","parsePeakTable","fastParse","parseXYDataRegExp","fastParseXYData","Object","keys","newNtuples","key","values","j","add2D","keepSpectra","isGCMS","newGCMS","xy","data","newData","x","y","k","addNewGCMS","addGCMS","value","toLowerCase","GC_MS_FIELDS","gcms","times","series","name","dimension","existingGCMSFields","label","gc","ms","shift","getMedian","sort","compareNumbers","Math","floor","a","b","convertTo3DZ","minZ","maxZ","ySize","xSize","z","xVector","minX","maxX","minY","maxY","noise","map","abs","zData","noContour","contourLines","generateContourLines","minMax","povarHeight0","povarHeight1","povarHeight2","povarHeight3","isOver0","isOver1","isOver2","isOver3","pAx","pAy","pBx","pBy","lineZValue","nbLevels","nbContourLevels","noiseMultiplier","undefined","nbSubSpectra","nbPovars","x0","xN","dx","y0","yN","dy","iter","contourLevels","level","contourLevel","side","exp","lines","zValue","iSubSpectra","subSpectra","subSpectraAfter","povar","segments","isXYdata","currentData","currentX","currentY","ascii","charCodeAt","newLine","isDifference","isLastDifference","lastDifference","isDuplicate","inComment","currentValue","isNegative","inValue","skipFirstValue","decimalPosition","pow","duplicate","ascii2","removeCommentRegExp","peakTableSplitRegExp","isPeaktable","jj","JcampConverter","input","useWorker","postToWorker","worker","createWorker","Promise","resolve","stamp","random","stamps","postMessage","JSON","stringify","workerURL","URL","createObjectURL","Blob","toString","type","Worker","revokeObjectURL","addEventListener","event","parse","output","xyDataSplitRegExp","DEBUG","currentPosition","lastDif","firstPoint","expectedCurrentX","String","fromCharCode","dup"],"mappings":"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","file":"jcampconverter.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JcampConverter\"] = factory();\n\telse\n\t\troot[\"JcampConverter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JcampConverter\"] = factory();\n\telse\n\t\troot[\"JcampConverter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar parseXYDataRegExp = __webpack_require__(1);\n\t\n\t\n\tfunction getConverter() {\n\t\n\t    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n\t    var ntuplesSeparator = /[, \\t]{1,}/;\n\t\n\t    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\t\n\t    function convertToFloatArray(stringArray) {\n\t        var l = stringArray.length;\n\t        var floatArray = new Array(l);\n\t        for (var i = 0; i < l; i++) {\n\t            floatArray[i] = parseFloat(stringArray[i]);\n\t        }\n\t        return floatArray;\n\t    }\n\t    \n\t    function Spectrum() {\n\t        \n\t    }\n\t\n\t    function convert(jcamp, options) {\n\t        options = options || {};\n\t\n\t        var keepRecordsRegExp = /^$/;\n\t        if (options.keepRecordsRegExp) keepRecordsRegExp = options.keepRecordsRegExp;\n\t        var wantXY = !options.withoutXY;\n\t\n\t        var start = Date.now();\n\t\n\t        var ntuples = {},\n\t            ldr,\n\t            dataLabel,\n\t            dataValue,\n\t            ldrs,\n\t            i, ii, position, endLine, infos;\n\t\n\t        var result = {};\n\t        result.profiling = [];\n\t        result.logs = [];\n\t        var spectra = [];\n\t        result.spectra = spectra;\n\t        result.info = {};\n\t        var spectrum = new Spectrum();\n\t\n\t        if (!(typeof jcamp === 'string')) return result;\n\t        // console.time('start');\n\t\n\t        if (result.profiling) result.profiling.push({\n\t            action: 'Before split to LDRS',\n\t            time: Date.now() - start\n\t        });\n\t\n\t        ldrs = jcamp.split(/[\\r\\n]+##/);\n\t\n\t        if (result.profiling) result.profiling.push({\n\t            action: 'Split to LDRS',\n\t            time: Date.now() - start\n\t        });\n\t\n\t        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\t\n\t        for (i = 0, ii = ldrs.length; i < ii; i++) {\n\t            ldr = ldrs[i];\n\t            // This is a new LDR\n\t            position = ldr.indexOf('=');\n\t            if (position > 0) {\n\t                dataLabel = ldr.substring(0, position);\n\t                dataValue = ldr.substring(position + 1).trim();\n\t            } else {\n\t                dataLabel = ldr;\n\t                dataValue = '';\n\t            }\n\t            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\t\n\t            if (dataLabel === 'DATATABLE') {\n\t                endLine = dataValue.indexOf('\\n');\n\t                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n\t                if (endLine > 0) {\n\t                    var xIndex = -1;\n\t                    var yIndex = -1;\n\t                    // ##DATA TABLE= (X++(I..I)), XYDATA\n\t                    // We need to find the variables\n\t\n\t                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n\t                    if (infos[0].indexOf('++') > 0) {\n\t                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n\t                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n\t                        xIndex = ntuples.symbol.indexOf(firstVariable);\n\t                        yIndex = ntuples.symbol.indexOf(secondVariable);\n\t                    }\n\t\n\t                    if (xIndex === -1) xIndex = 0;\n\t                    if (yIndex === -1) yIndex = 0;\n\t\n\t                    if (ntuples.first) {\n\t                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n\t                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n\t                    }\n\t                    if (ntuples.last) {\n\t                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n\t                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n\t                    }\n\t                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n\t                        spectrum.nbPoints = ntuples.vardim[xIndex];\n\t                    }\n\t                    if (ntuples.factor) {\n\t                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n\t                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n\t                    }\n\t                    if (ntuples.units) {\n\t                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n\t                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n\t                    }\n\t                    spectrum.datatable = infos[0];\n\t                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n\t                        dataLabel = 'PEAKTABLE';\n\t                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n\t                        dataLabel = 'XYDATA';\n\t                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (dataLabel === 'XYDATA') {\n\t                if (wantXY) {\n\t                    prepareSpectrum(result, spectrum);\n\t                    // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n\t                    if (dataValue.match(/.*\\+\\+.*/)) {\n\t                        if (options.fastParse === false) {\n\t                            parseXYDataRegExp(spectrum, dataValue, result);\n\t                        } else {\n\t                            if (!spectrum.deltaX) {\n\t                                spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t                            }\n\t                            fastParseXYData(spectrum, dataValue, result);\n\t                        }\n\t                    } else {\n\t                        parsePeakTable(spectrum, dataValue, result);\n\t                    }\n\t                    spectra.push(spectrum);\n\t                    spectrum = new Spectrum();\n\t                }\n\t                continue;\n\t            } else if (dataLabel === 'PEAKTABLE') {\n\t                if (wantXY) {\n\t                    prepareSpectrum(result, spectrum);\n\t                    parsePeakTable(spectrum, dataValue, result);\n\t                    spectra.push(spectrum);\n\t                    spectrum = new Spectrum();\n\t                }\n\t                continue;\n\t            }\n\t\n\t\n\t            if (dataLabel === 'TITLE') {\n\t                spectrum.title = dataValue;\n\t            } else if (dataLabel === 'DATATYPE') {\n\t                spectrum.dataType = dataValue;\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'NTUPLES') {\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'XUNITS') {\n\t                spectrum.xUnit = dataValue;\n\t            } else if (dataLabel === 'YUNITS') {\n\t                spectrum.yUnit = dataValue;\n\t            } else if (dataLabel === 'FIRSTX') {\n\t                spectrum.firstX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTX') {\n\t                spectrum.lastX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'FIRSTY') {\n\t                spectrum.firstY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTY') {\n\t                spectrum.lastY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'NPOINTS') {\n\t                spectrum.nbPoints = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XFACTOR') {\n\t                spectrum.xFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'YFACTOR') {\n\t                spectrum.yFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'DELTAX') {\n\t                spectrum.deltaX = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n\t                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVENUCLEUS') {\n\t                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n\t            } else if (dataLabel === '$SFO2') {\n\t                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\t\n\t            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n\t                result.shiftOffsetNum = 0;\n\t                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n\t            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\t\n\t\n\t                // if we activate this part it does not work for ACD specmanager\n\t                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n\t                //                 var parts = dataValue.split(/ *, */);\n\t                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n\t                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n\t            } else if (dataLabel === 'VARNAME') {\n\t                ntuples.varname = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'SYMBOL') {\n\t                ntuples.symbol = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARTYPE') {\n\t                ntuples.vartype = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARFORM') {\n\t                ntuples.varform = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARDIM') {\n\t                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'UNITS') {\n\t                ntuples.units = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'FACTOR') {\n\t                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'FIRST') {\n\t                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'LAST') {\n\t                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'MIN') {\n\t                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'MAX') {\n\t                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === '.NUCLEUS') {\n\t                if (result.twoD) {\n\t                    result.yType = dataValue.split(ntuplesSeparator)[0];\n\t                }\n\t            } else if (dataLabel === 'PAGE') {\n\t                spectrum.page = dataValue.trim();\n\t                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n\t                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n\t                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n\t                var unit = '';\n\t                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n\t                    unit = ntuples.units[pageSymbolIndex];\n\t                }\n\t                if (result.indirectFrequency && unit !== 'PPM') {\n\t                    spectrum.pageValue /= result.indirectFrequency;\n\t                }\n\t            } else if (dataLabel === 'RETENTIONTIME') {\n\t                spectrum.pageValue = parseFloat(dataValue);\n\t            } else if (isMSField(dataLabel)) {\n\t                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n\t            }\n\t            if (dataLabel.match(keepRecordsRegExp)) {\n\t                result.info[dataLabel] = dataValue.trim();\n\t            }\n\t        }\n\t\n\t        if (result.profiling) result.profiling.push({\n\t            action: 'Finished parsing',\n\t            time: Date.now() - start\n\t        });\n\t\n\t        if (Object.keys(ntuples).length > 0) {\n\t            var newNtuples = [];\n\t            var keys = Object.keys(ntuples);\n\t            for (var i = 0; i < keys.length; i++) {\n\t                var key = keys[i];\n\t                var values = ntuples[key];\n\t                for (var j = 0; j < values.length; j++) {\n\t                    if (!newNtuples[j]) newNtuples[j] = {};\n\t                    newNtuples[j][key] = values[j];\n\t                }\n\t            }\n\t            result.ntuples = newNtuples;\n\t        }\n\t\n\t        if (result.twoD && wantXY) {\n\t            add2D(result, options);\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished countour plot calculation',\n\t                time: Date.now() - start\n\t            });\n\t            if (!options.keepSpectra) {\n\t                delete result.spectra;\n\t            }\n\t        }\n\t\n\t        var isGCMS = (spectra.length > 1 && (!spectra[0].dataType || spectra[0].dataType.match(/.*mass.*/i)));\n\t        if (isGCMS && options.newGCMS) {\n\t            options.xy = true;\n\t        }\n\t\n\t        if (options.xy && wantXY) { // the spectraData should not be a oneD array but an object with x and y\n\t            if (spectra.length > 0) {\n\t                for (var i = 0; i < spectra.length; i++) {\n\t                    var spectrum = spectra[i];\n\t                    if (spectrum.data.length > 0) {\n\t                        for (var j = 0; j < spectrum.data.length; j++) {\n\t                            var data = spectrum.data[j];\n\t                            var newData = {\n\t                                x: new Array(data.length / 2),\n\t                                y: new Array(data.length / 2)\n\t                            };\n\t                            for (var k = 0; k < data.length; k = k + 2) {\n\t                                newData.x[k / 2] = data[k];\n\t                                newData.y[k / 2] = data[k + 1];\n\t                            }\n\t                            spectrum.data[j] = newData;\n\t                        }\n\t\n\t                    }\n\t\n\t                }\n\t            }\n\t        }\n\t\n\t        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n\t        if (isGCMS && wantXY) {\n\t            if (options.newGCMS) {\n\t                addNewGCMS(result);\n\t            } else {\n\t                addGCMS(result);\n\t            }\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished GCMS calculation',\n\t                time: Date.now() - start\n\t            });\n\t        }\n\t\n\t        if (result.profiling) {\n\t            result.profiling.push({\n\t                action: 'Total time',\n\t                time: Date.now() - start\n\t            });\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t\n\t    function convertMSFieldToLabel(value) {\n\t        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n\t    }\n\t\n\t    function isMSField(dataLabel) {\n\t        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n\t    }\n\t\n\t    function addNewGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var length = spectra.length;\n\t        var gcms = {\n\t            times: new Array(length),\n\t            series: [{\n\t                name: 'ms',\n\t                dimension: 2,\n\t                data: new Array(length)\n\t            }]\n\t        };\n\t\n\t        var i;\n\t        var existingGCMSFields = [];\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t                gcms.series.push({\n\t                    name: label,\n\t                    dimension: 1,\n\t                    data: new Array(length)\n\t                });\n\t            }\n\t        }\n\t\n\t        for (i = 0; i < length; i++) {\n\t            var spectrum = spectra[i];\n\t            gcms.times[i] = spectrum.pageValue;\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.series[j + 1].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n\t            }\n\t            if (spectrum.data) {\n\t                gcms.series[0].data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n\t            }\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function addGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var existingGCMSFields = [];\n\t        var i;\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t            }\n\t        }\n\t        if (existingGCMSFields.length === 0) return;\n\t        var gcms = {};\n\t        gcms.gc = {};\n\t        gcms.ms = [];\n\t        for (i = 0; i < existingGCMSFields.length; i++) {\n\t            gcms.gc[existingGCMSFields[i]] = [];\n\t        }\n\t        for (i = 0; i < spectra.length; i++) {\n\t            var spectrum = spectra[i];\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n\t                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n\t            }\n\t            if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function prepareSpectrum(result, spectrum) {\n\t        if (!spectrum.xFactor) spectrum.xFactor = 1;\n\t        if (!spectrum.yFactor) spectrum.yFactor = 1;\n\t        if (spectrum.observeFrequency) {\n\t            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n\t                spectrum.xUnit = 'PPM';\n\t                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n\t                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n\t                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n\t                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n\t            }\n\t        }\n\t        if (result.shiftOffsetVal) {\n\t            var shift = spectrum.firstX - result.shiftOffsetVal;\n\t            spectrum.firstX = spectrum.firstX - shift;\n\t            spectrum.lastX = spectrum.lastX - shift;\n\t        }\n\t    }\n\t\n\t    function getMedian(data) {\n\t        data = data.sort(compareNumbers);\n\t        var l = data.length;\n\t        return data[Math.floor(l / 2)];\n\t    }\n\t\n\t    function compareNumbers(a, b) {\n\t        return a - b;\n\t    }\n\t\n\t    function convertTo3DZ(spectra) {\n\t        var minZ = spectra[0].data[0][0];\n\t        var maxZ = minZ;\n\t        var ySize = spectra.length;\n\t        var xSize = spectra[0].data[0].length / 2;\n\t        var z = new Array(ySize);\n\t        for (var i = 0; i < ySize; i++) {\n\t            z[i] = new Array(xSize);\n\t            var xVector = spectra[i].data[0];\n\t            for (var j = 0; j < xSize; j++) {\n\t                var value = xVector[j * 2 + 1];\n\t                z[i][j] = value;\n\t                if (value < minZ) minZ = value;\n\t                if (value > maxZ) maxZ = value;\n\t            }\n\t        }\n\t        return {\n\t            z: z,\n\t            minX: spectra[0].data[0][0],\n\t            maxX: spectra[0].data[0][spectra[0].data[0].length - 2], // has to be -2 because it is a 1D array [x,y,x,y,...]\n\t            minY: spectra[0].pageValue,\n\t            maxY: spectra[ySize - 1].pageValue,\n\t            minZ: minZ,\n\t            maxZ: maxZ,\n\t            noise: getMedian(z[0].map(Math.abs))\n\t        };\n\t\n\t    }\n\t\n\t    function add2D(result, options) {\n\t        var zData = convertTo3DZ(result.spectra);\n\t        if (!options.noContour) {\n\t            result.contourLines = generateContourLines(zData, options);\n\t            delete zData.z;\n\t        }\n\t        result.minMax = zData;\n\t    }\n\t\n\t\n\t    function generateContourLines(zData, options) {\n\t        var noise = zData.noise;\n\t        var z = zData.z;\n\t        var nbLevels = options.nbContourLevels || 7;\n\t        var noiseMultiplier = options.noiseMultiplier === undefined ? 5 : options.noiseMultiplier;\n\t        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n\t        var isOver0, isOver1, isOver2, isOver3;\n\t        var nbSubSpectra = z.length;\n\t        var nbPovars = z[0].length;\n\t        var pAx, pAy, pBx, pBy;\n\t\n\t        var x0 = zData.minX;\n\t        var xN = zData.maxX;\n\t        var dx = (xN - x0) / (nbPovars - 1);\n\t        var y0 = zData.minY;\n\t        var yN = zData.maxY;\n\t        var dy = (yN - y0) / (nbSubSpectra - 1);\n\t        var minZ = zData.minZ;\n\t        var maxZ = zData.maxZ;\n\t\n\t        //System.out.prvarln('y0 '+y0+' yN '+yN);\n\t        // -------------------------\n\t        // Povars attribution\n\t        //\n\t        // 0----1\n\t        // |  / |\n\t        // | /  |\n\t        // 2----3\n\t        //\n\t        // ---------------------d------\n\t\n\t        var iter = nbLevels * 2;\n\t        var contourLevels = new Array(iter);\n\t        var lineZValue;\n\t        for (var level = 0; level < iter; level++) { // multiply by 2 for positif and negatif\n\t            var contourLevel = {};\n\t            contourLevels[level] = contourLevel;\n\t            var side = level % 2;\n\t            var factor = (maxZ - noiseMultiplier * noise) * Math.exp((level >> 1) - nbLevels);\n\t            if (side === 0) {\n\t                lineZValue = factor + noiseMultiplier * noise;\n\t            } else {\n\t                lineZValue = (0 - factor) - noiseMultiplier * noise;\n\t            }\n\t            var lines = [];\n\t            contourLevel.zValue = lineZValue;\n\t            contourLevel.lines = lines;\n\t\n\t            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\t\n\t            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n\t                var subSpectra = z[iSubSpectra];\n\t                var subSpectraAfter = z[iSubSpectra + 1];\n\t                for (var povar = 0; povar < nbPovars - 1; povar++) {\n\t                    povarHeight0 = subSpectra[povar];\n\t                    povarHeight1 = subSpectra[povar + 1];\n\t                    povarHeight2 = subSpectraAfter[povar];\n\t                    povarHeight3 = subSpectraAfter[povar + 1];\n\t\n\t                    isOver0 = (povarHeight0 > lineZValue);\n\t                    isOver1 = (povarHeight1 > lineZValue);\n\t                    isOver2 = (povarHeight2 > lineZValue);\n\t                    isOver3 = (povarHeight3 > lineZValue);\n\t\n\t                    // Example povar0 is over the plane and povar1 and\n\t                    // povar2 are below, we find the varersections and add\n\t                    // the segment\n\t                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n\t                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n\t                        pAy = iSubSpectra;\n\t                        pBx = povar;\n\t                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n\t                        lines.push(pAx * dx + x0);\n\t                        lines.push(pAy * dy + y0);\n\t                        lines.push(pBx * dx + x0);\n\t                        lines.push(pBy * dy + y0);\n\t                    }\n\t                    // remove push does not help !!!!\n\t                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n\t                        pAx = povar + 1;\n\t                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n\t                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n\t                        pBy = iSubSpectra + 1;\n\t                        lines.push(pAx * dx + x0);\n\t                        lines.push(pAy * dy + y0);\n\t                        lines.push(pBx * dx + x0);\n\t                        lines.push(pBy * dy + y0);\n\t                    }\n\t                    // test around the diagonal\n\t                    if (isOver1 !== isOver2) {\n\t                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n\t                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n\t                        if (isOver1 !== isOver0) {\n\t                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n\t                            pBy = iSubSpectra;\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver2 !== isOver0) {\n\t                            pBx = povar;\n\t                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver1 !== isOver3) {\n\t                            pBx = povar + 1;\n\t                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver2 !== isOver3) {\n\t                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n\t                            pBy = iSubSpectra + 1;\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        return {\n\t            minX: zData.minX,\n\t            maxX: zData.maxX,\n\t            minY: zData.minY,\n\t            maxY: zData.maxY,\n\t            segments: contourLevels\n\t        };\n\t    }\n\t\n\t    function fastParseXYData(spectrum, value) {\n\t        // TODO need to deal with result\n\t        //  console.log(value);\n\t        // we check if deltaX is defined otherwise we calculate it\n\t\n\t        var yFactor = spectrum.yFactor;\n\t        var deltaX = spectrum.deltaX;\n\t\n\t\n\t        spectrum.isXYdata = true;\n\t        // TODO to be improved using 2 array {x:[], y:[]}\n\t        var currentData = [];\n\t        spectrum.data = [currentData];\n\t\n\t\n\t        var currentX = spectrum.firstX;\n\t        var currentY = spectrum.firstY;\n\t\n\t        // we skip the first line\n\t        //\n\t        var endLine = false;\n\t        for (var i = 0; i < value.length; i++) {\n\t            var ascii = value.charCodeAt(i);\n\t            if (ascii === 13 || ascii === 10) {\n\t                endLine = true;\n\t            } else {\n\t                if (endLine) break;\n\t            }\n\t        }\n\t\n\t        // we proceed taking the i after the first line\n\t        var newLine = true;\n\t        var isDifference = false;\n\t        var isLastDifference = false;\n\t        var lastDifference = 0;\n\t        var isDuplicate = false;\n\t        var inComment = false;\n\t        var currentValue = 0;\n\t        var isNegative = false;\n\t        var inValue = false;\n\t        var skipFirstValue = false;\n\t        var decimalPosition = 0;\n\t        var ascii;\n\t        for (; i <= value.length; i++) {\n\t            if (i === value.length) ascii = 13;\n\t            else ascii = value.charCodeAt(i);\n\t            if (inComment) {\n\t                // we should ignore the text if we are after $$\n\t                if (ascii === 13 || ascii === 10) {\n\t                    newLine = true;\n\t                    inComment = false;\n\t                }\n\t            } else {\n\t                // when is it a new value ?\n\t                // when it is not a digit, . or comma\n\t                // it is a number that is either new or we continue\n\t                if (ascii <= 57 && ascii >= 48) { // a number\n\t                    inValue = true;\n\t                    if (decimalPosition > 0) {\n\t                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n\t                    } else {\n\t                        currentValue *= 10;\n\t                        currentValue += ascii - 48;\n\t                    }\n\t                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n\t                    inValue = true;\n\t                    decimalPosition++;\n\t                } else {\n\t                    if (inValue) {\n\t                        // need to process the previous value\n\t                        if (newLine) {\n\t                            newLine = false; // we don't check the X value\n\t                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n\t                            // if new line and lastDifference, the first value is just a check !\n\t                            // that we don't check ...\n\t                            if (isLastDifference) skipFirstValue = true;\n\t                        } else {\n\t                            // need to deal with duplicate and differences\n\t                            if (skipFirstValue) {\n\t                                skipFirstValue = false;\n\t                            } else {\n\t                                if (isDifference) {\n\t                                    lastDifference = isNegative ? (0 - currentValue) : currentValue;\n\t                                    isLastDifference = true;\n\t                                    isDifference = false;\n\t                                }\n\t                                var duplicate = isDuplicate ? currentValue - 1 : 1;\n\t                                for (var j = 0; j < duplicate; j++) {\n\t                                    if (isLastDifference) {\n\t                                        currentY += lastDifference;\n\t                                    } else {\n\t                                        currentY = isNegative ? (0 - currentValue) : currentValue;\n\t                                    }\n\t                                    currentData.push(currentX);\n\t                                    currentData.push(currentY * yFactor);\n\t                                    currentX += deltaX;\n\t                                }\n\t                            }\n\t                        }\n\t                        isNegative = false;\n\t                        currentValue = 0;\n\t                        decimalPosition = 0;\n\t                        inValue = false;\n\t                        isDuplicate = false;\n\t                    }\n\t\n\t                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                    if ((ascii < 74) && (ascii > 63)) {\n\t                        inValue = true;\n\t                        isLastDifference = false;\n\t                        currentValue = ascii - 64;\n\t                    } else\n\t                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                    if ((ascii > 96) && (ascii < 106)) {\n\t                        inValue = true;\n\t                        isLastDifference = false;\n\t                        currentValue = ascii - 96;\n\t                        isNegative = true;\n\t                    } else\n\t                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                    if (ascii === 115) {\n\t                        inValue = true;\n\t                        isDuplicate = true;\n\t                        currentValue = 9;\n\t                    } else if ((ascii > 82) && (ascii < 91)) {\n\t                        inValue = true;\n\t                        isDuplicate = true;\n\t                        currentValue = ascii - 82;\n\t                    } else\n\t                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                    if ((ascii > 73) && (ascii < 83)) {\n\t                        inValue = true;\n\t                        isDifference = true;\n\t                        currentValue = ascii - 73;\n\t                    } else\n\t                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                    if ((ascii > 105) && (ascii < 115)) {\n\t                        inValue = true;\n\t                        isDifference = true;\n\t                        currentValue = ascii - 105;\n\t                        isNegative = true;\n\t                    } else\n\t                    // $ sign, we need to check the next one\n\t                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n\t                        inValue = true;\n\t                        inComment = true;\n\t                    } else\n\t                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                    if (ascii === 37) {\n\t                        inValue = true;\n\t                        isDifference = true;\n\t                        currentValue = 0;\n\t                        isNegative = false;\n\t                    } else if (ascii === 45) { // a \"-\"\n\t                        // check if after there is a number, decimal or comma\n\t                        var ascii2 = value.charCodeAt(i + 1);\n\t                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n\t                            inValue = true;\n\t                            isLastDifference = false;\n\t                            isNegative = true;\n\t                        }\n\t                    } else if (ascii === 13 || ascii === 10) {\n\t                        newLine = true;\n\t                        inComment = false;\n\t                    }\n\t                    // and now analyse the details ... space or tabulation\n\t                    // if \"+\" we just don't care\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function parsePeakTable(spectrum, value, result) {\n\t        var removeCommentRegExp = /\\$\\$.*/;\n\t        var peakTableSplitRegExp = /[,\\t ]+/;\n\t\n\t        spectrum.isPeaktable = true;\n\t        var i, ii, j, jj, values;\n\t        var currentData = [];\n\t        spectrum.data = [currentData];\n\t\n\t        // counts for around 20% of the time\n\t        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\t\n\t        for (i = 1, ii = lines.length; i < ii; i++) {\n\t            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n\t            if (values.length % 2 === 0) {\n\t                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n\t                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n\t                    currentData.push(parseFloat(values[j]) * spectrum.xFactor);\n\t                    currentData.push(parseFloat(values[j + 1]) * spectrum.yFactor);\n\t                }\n\t            } else {\n\t                result.logs.push('Format error: ' + values);\n\t            }\n\t        }\n\t    }\n\t\n\t\n\t    return convert;\n\t\n\t}\n\t\n\tvar convert = getConverter();\n\t\n\tfunction JcampConverter(input, options, useWorker) {\n\t    if (typeof options === 'boolean') {\n\t        useWorker = options;\n\t        options = {};\n\t    }\n\t    if (useWorker) {\n\t        return postToWorker(input, options);\n\t    } else {\n\t        return convert(input, options);\n\t    }\n\t}\n\t\n\tvar stamps = {},\n\t    worker;\n\t\n\tfunction postToWorker(input, options) {\n\t    if (!worker) {\n\t        createWorker();\n\t    }\n\t    return new Promise(function (resolve) {\n\t        var stamp = Date.now() + '' + Math.random();\n\t        stamps[stamp] = resolve;\n\t        worker.postMessage(JSON.stringify({\n\t            stamp: stamp,\n\t            input: input,\n\t            options: options\n\t        }));\n\t    });\n\t}\n\t\n\tfunction createWorker() {\n\t    var workerURL = URL.createObjectURL(new Blob([\n\t        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { var data = JSON.parse(event.data); postMessage(JSON.stringify({stamp: data.stamp, output: convert(data.input, data.options)})); };'\n\t    ], {type: 'application/javascript'}));\n\t    worker = new Worker(workerURL);\n\t    URL.revokeObjectURL(workerURL);\n\t    worker.addEventListener('message', function (event) {\n\t        var data = JSON.parse(event.data);\n\t        var stamp = data.stamp;\n\t        if (stamps[stamp]) {\n\t            stamps[stamp](data.output);\n\t        }\n\t    });\n\t}\n\t\n\tmodule.exports = {\n\t    convert: JcampConverter\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\tvar xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\n\tvar removeCommentRegExp = /\\$\\$.*/;\n\tvar DEBUG=false;\n\t\n\tmodule.exports=function(spectrum, value, result) {\n\t    // we check if deltaX is defined otherwise we calculate it\n\t    if (!spectrum.deltaX) {\n\t        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t    }\n\t\n\t    spectrum.isXYdata=true;\n\t\n\t    var currentData = [];\n\t    var currentPosition=0;\n\t    spectrum.data = [currentData];\n\t\n\t    var currentX = spectrum.firstX;\n\t    var currentY = spectrum.firstY;\n\t    var lines = value.split(/[\\r\\n]+/);\n\t    var lastDif, values, ascii, expectedY;\n\t    values = [];\n\t    for (var i = 1, ii = lines.length; i < ii; i++) {\n\t        //var previousValues=JSON.parse(JSON.stringify(values));\n\t        values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n\t        if (values.length > 0) {\n\t            if (DEBUG) {\n\t                if (!spectrum.firstPoint) {\n\t                    spectrum.firstPoint = +values[0];\n\t                }\n\t                var expectedCurrentX = (values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n\t                if ((lastDif || lastDif === 0)) {\n\t                    expectedCurrentX += spectrum.deltaX;\n\t                }\n\t                result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n\t            }\n\t            for (var j = 1, jj = values.length; j < jj; j++) {\n\t                if (j === 1 && (lastDif || lastDif === 0)) {\n\t                    lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n\t                    // we could check if we have the expected Y value\n\t                    ascii = values[j].charCodeAt(0);\n\t\n\t                    if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n\t                        // + - . 0 1 2 3 4 5 6 7 8 9\n\t                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                            expectedY = +values[j];\n\t                        } else\n\t                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                        if ((ascii > 63) && (ascii < 74)) {\n\t                            expectedY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                        } else\n\t                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                        if ((ascii > 96) && (ascii < 106)) {\n\t                            expectedY = -(String.fromCharCode(ascii - 48) + values[j].substring(1));\n\t                        }\n\t                        if (expectedY !== currentY) {\n\t                            result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n\t                            result.logs.push('Previous values: ' + previousValues.length);\n\t                            result.logs.push(previousValues);\n\t                        }\n\t                    }\n\t                } else {\n\t                    if (values[j].length > 0) {\n\t                        ascii = values[j].charCodeAt(0);\n\t                        // + - . 0 1 2 3 4 5 6 7 8 9\n\t                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                            lastDif = null;\n\t                            currentY = +values[j];\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                        if ((ascii > 63) && (ascii < 74)) {\n\t                            lastDif = null;\n\t                            currentY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++] = currentX;\n\t                            currentData[currentPosition++] = currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                        if ((ascii > 96) && (ascii < 106)) {\n\t                            lastDif = null;\n\t                            // we can multiply the string by 1 because if may not contain decimal (is this correct ????)\n\t                            currentY = -(String.fromCharCode(ascii - 48) + values[j].substring(1))*1;\n\t                            //currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t\n\t\n\t\n\t                        // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                        if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n\t                            var dup = (String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n\t                            if (ascii === 115) {\n\t                                dup = ('9' + values[j].substring(1)) - 1;\n\t                            }\n\t                            for (var l = 0; l < dup; l++) {\n\t                                if (lastDif) {\n\t                                    currentY = currentY + lastDif;\n\t                                }\n\t                                // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                                currentData[currentPosition++]=currentX;\n\t                                currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                                currentX += spectrum.deltaX;\n\t                            }\n\t                        } else\n\t                        // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                        if (ascii === 37) {\n\t                            lastDif = +('0' + values[j].substring(1));\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else if ((ascii > 73) && (ascii < 83)) {\n\t                            lastDif = (String.fromCharCode(ascii - 25) + values[j].substring(1))*1;\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                        if ((ascii > 105) && (ascii < 115)) {\n\t                            lastDif = -(String.fromCharCode(ascii - 57) + values[j].substring(1))*1;\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** jcampconverter.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f4c83f47ab05faac88b9\n **/","'use strict';\n\nvar parseXYDataRegExp = require('./parseXYData.js');\n\n\nfunction getConverter() {\n\n    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n    var ntuplesSeparator = /[, \\t]{1,}/;\n\n    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\n    function convertToFloatArray(stringArray) {\n        var l = stringArray.length;\n        var floatArray = new Array(l);\n        for (var i = 0; i < l; i++) {\n            floatArray[i] = parseFloat(stringArray[i]);\n        }\n        return floatArray;\n    }\n    \n    function Spectrum() {\n        \n    }\n\n    function convert(jcamp, options) {\n        options = options || {};\n\n        var keepRecordsRegExp = /^$/;\n        if (options.keepRecordsRegExp) keepRecordsRegExp = options.keepRecordsRegExp;\n        var wantXY = !options.withoutXY;\n\n        var start = Date.now();\n\n        var ntuples = {},\n            ldr,\n            dataLabel,\n            dataValue,\n            ldrs,\n            i, ii, position, endLine, infos;\n\n        var result = {};\n        result.profiling = [];\n        result.logs = [];\n        var spectra = [];\n        result.spectra = spectra;\n        result.info = {};\n        var spectrum = new Spectrum();\n\n        if (!(typeof jcamp === 'string')) return result;\n        // console.time('start');\n\n        if (result.profiling) result.profiling.push({\n            action: 'Before split to LDRS',\n            time: Date.now() - start\n        });\n\n        ldrs = jcamp.split(/[\\r\\n]+##/);\n\n        if (result.profiling) result.profiling.push({\n            action: 'Split to LDRS',\n            time: Date.now() - start\n        });\n\n        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n        for (i = 0, ii = ldrs.length; i < ii; i++) {\n            ldr = ldrs[i];\n            // This is a new LDR\n            position = ldr.indexOf('=');\n            if (position > 0) {\n                dataLabel = ldr.substring(0, position);\n                dataValue = ldr.substring(position + 1).trim();\n            } else {\n                dataLabel = ldr;\n                dataValue = '';\n            }\n            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n            if (dataLabel === 'DATATABLE') {\n                endLine = dataValue.indexOf('\\n');\n                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n                if (endLine > 0) {\n                    var xIndex = -1;\n                    var yIndex = -1;\n                    // ##DATA TABLE= (X++(I..I)), XYDATA\n                    // We need to find the variables\n\n                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n                    if (infos[0].indexOf('++') > 0) {\n                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n                        xIndex = ntuples.symbol.indexOf(firstVariable);\n                        yIndex = ntuples.symbol.indexOf(secondVariable);\n                    }\n\n                    if (xIndex === -1) xIndex = 0;\n                    if (yIndex === -1) yIndex = 0;\n\n                    if (ntuples.first) {\n                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n                    }\n                    if (ntuples.last) {\n                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n                    }\n                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n                        spectrum.nbPoints = ntuples.vardim[xIndex];\n                    }\n                    if (ntuples.factor) {\n                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n                    }\n                    if (ntuples.units) {\n                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n                    }\n                    spectrum.datatable = infos[0];\n                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n                        dataLabel = 'PEAKTABLE';\n                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n                        dataLabel = 'XYDATA';\n                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                    }\n                }\n            }\n\n            if (dataLabel === 'XYDATA') {\n                if (wantXY) {\n                    prepareSpectrum(result, spectrum);\n                    // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n                    if (dataValue.match(/.*\\+\\+.*/)) {\n                        if (options.fastParse === false) {\n                            parseXYDataRegExp(spectrum, dataValue, result);\n                        } else {\n                            if (!spectrum.deltaX) {\n                                spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                            }\n                            fastParseXYData(spectrum, dataValue, result);\n                        }\n                    } else {\n                        parsePeakTable(spectrum, dataValue, result);\n                    }\n                    spectra.push(spectrum);\n                    spectrum = new Spectrum();\n                }\n                continue;\n            } else if (dataLabel === 'PEAKTABLE') {\n                if (wantXY) {\n                    prepareSpectrum(result, spectrum);\n                    parsePeakTable(spectrum, dataValue, result);\n                    spectra.push(spectrum);\n                    spectrum = new Spectrum();\n                }\n                continue;\n            }\n\n\n            if (dataLabel === 'TITLE') {\n                spectrum.title = dataValue;\n            } else if (dataLabel === 'DATATYPE') {\n                spectrum.dataType = dataValue;\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'NTUPLES') {\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'XUNITS') {\n                spectrum.xUnit = dataValue;\n            } else if (dataLabel === 'YUNITS') {\n                spectrum.yUnit = dataValue;\n            } else if (dataLabel === 'FIRSTX') {\n                spectrum.firstX = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTX') {\n                spectrum.lastX = parseFloat(dataValue);\n            } else if (dataLabel === 'FIRSTY') {\n                spectrum.firstY = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTY') {\n                spectrum.lastY = parseFloat(dataValue);\n            } else if (dataLabel === 'NPOINTS') {\n                spectrum.nbPoints = parseFloat(dataValue);\n            } else if (dataLabel === 'XFACTOR') {\n                spectrum.xFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'YFACTOR') {\n                spectrum.yFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'DELTAX') {\n                spectrum.deltaX = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVENUCLEUS') {\n                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n            } else if (dataLabel === '$SFO2') {\n                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\n            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n                result.shiftOffsetNum = 0;\n                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\n\n                // if we activate this part it does not work for ACD specmanager\n                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n                //                 var parts = dataValue.split(/ *, */);\n                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n            } else if (dataLabel === 'VARNAME') {\n                ntuples.varname = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'SYMBOL') {\n                ntuples.symbol = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARTYPE') {\n                ntuples.vartype = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARFORM') {\n                ntuples.varform = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARDIM') {\n                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'UNITS') {\n                ntuples.units = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'FACTOR') {\n                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'FIRST') {\n                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'LAST') {\n                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MIN') {\n                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MAX') {\n                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === '.NUCLEUS') {\n                if (result.twoD) {\n                    result.yType = dataValue.split(ntuplesSeparator)[0];\n                }\n            } else if (dataLabel === 'PAGE') {\n                spectrum.page = dataValue.trim();\n                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n                var unit = '';\n                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n                    unit = ntuples.units[pageSymbolIndex];\n                }\n                if (result.indirectFrequency && unit !== 'PPM') {\n                    spectrum.pageValue /= result.indirectFrequency;\n                }\n            } else if (dataLabel === 'RETENTIONTIME') {\n                spectrum.pageValue = parseFloat(dataValue);\n            } else if (isMSField(dataLabel)) {\n                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n            }\n            if (dataLabel.match(keepRecordsRegExp)) {\n                result.info[dataLabel] = dataValue.trim();\n            }\n        }\n\n        if (result.profiling) result.profiling.push({\n            action: 'Finished parsing',\n            time: Date.now() - start\n        });\n\n        if (Object.keys(ntuples).length > 0) {\n            var newNtuples = [];\n            var keys = Object.keys(ntuples);\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var values = ntuples[key];\n                for (var j = 0; j < values.length; j++) {\n                    if (!newNtuples[j]) newNtuples[j] = {};\n                    newNtuples[j][key] = values[j];\n                }\n            }\n            result.ntuples = newNtuples;\n        }\n\n        if (result.twoD && wantXY) {\n            add2D(result, options);\n            if (result.profiling) result.profiling.push({\n                action: 'Finished countour plot calculation',\n                time: Date.now() - start\n            });\n            if (!options.keepSpectra) {\n                delete result.spectra;\n            }\n        }\n\n        var isGCMS = (spectra.length > 1 && (!spectra[0].dataType || spectra[0].dataType.match(/.*mass.*/i)));\n        if (isGCMS && options.newGCMS) {\n            options.xy = true;\n        }\n\n        if (options.xy && wantXY) { // the spectraData should not be a oneD array but an object with x and y\n            if (spectra.length > 0) {\n                for (var i = 0; i < spectra.length; i++) {\n                    var spectrum = spectra[i];\n                    if (spectrum.data.length > 0) {\n                        for (var j = 0; j < spectrum.data.length; j++) {\n                            var data = spectrum.data[j];\n                            var newData = {\n                                x: new Array(data.length / 2),\n                                y: new Array(data.length / 2)\n                            };\n                            for (var k = 0; k < data.length; k = k + 2) {\n                                newData.x[k / 2] = data[k];\n                                newData.y[k / 2] = data[k + 1];\n                            }\n                            spectrum.data[j] = newData;\n                        }\n\n                    }\n\n                }\n            }\n        }\n\n        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n        if (isGCMS && wantXY) {\n            if (options.newGCMS) {\n                addNewGCMS(result);\n            } else {\n                addGCMS(result);\n            }\n            if (result.profiling) result.profiling.push({\n                action: 'Finished GCMS calculation',\n                time: Date.now() - start\n            });\n        }\n\n        if (result.profiling) {\n            result.profiling.push({\n                action: 'Total time',\n                time: Date.now() - start\n            });\n        }\n\n        return result;\n    }\n\n\n    function convertMSFieldToLabel(value) {\n        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n    }\n\n    function isMSField(dataLabel) {\n        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n    }\n\n    function addNewGCMS(result) {\n        var spectra = result.spectra;\n        var length = spectra.length;\n        var gcms = {\n            times: new Array(length),\n            series: [{\n                name: 'ms',\n                dimension: 2,\n                data: new Array(length)\n            }]\n        };\n\n        var i;\n        var existingGCMSFields = [];\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n                gcms.series.push({\n                    name: label,\n                    dimension: 1,\n                    data: new Array(length)\n                });\n            }\n        }\n\n        for (i = 0; i < length; i++) {\n            var spectrum = spectra[i];\n            gcms.times[i] = spectrum.pageValue;\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.series[j + 1].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n            }\n            if (spectrum.data) {\n                gcms.series[0].data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n            }\n\n        }\n        result.gcms = gcms;\n    }\n\n    function addGCMS(result) {\n        var spectra = result.spectra;\n        var existingGCMSFields = [];\n        var i;\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n            }\n        }\n        if (existingGCMSFields.length === 0) return;\n        var gcms = {};\n        gcms.gc = {};\n        gcms.ms = [];\n        for (i = 0; i < existingGCMSFields.length; i++) {\n            gcms.gc[existingGCMSFields[i]] = [];\n        }\n        for (i = 0; i < spectra.length; i++) {\n            var spectrum = spectra[i];\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n            }\n            if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\n        }\n        result.gcms = gcms;\n    }\n\n    function prepareSpectrum(result, spectrum) {\n        if (!spectrum.xFactor) spectrum.xFactor = 1;\n        if (!spectrum.yFactor) spectrum.yFactor = 1;\n        if (spectrum.observeFrequency) {\n            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n                spectrum.xUnit = 'PPM';\n                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n            }\n        }\n        if (result.shiftOffsetVal) {\n            var shift = spectrum.firstX - result.shiftOffsetVal;\n            spectrum.firstX = spectrum.firstX - shift;\n            spectrum.lastX = spectrum.lastX - shift;\n        }\n    }\n\n    function getMedian(data) {\n        data = data.sort(compareNumbers);\n        var l = data.length;\n        return data[Math.floor(l / 2)];\n    }\n\n    function compareNumbers(a, b) {\n        return a - b;\n    }\n\n    function convertTo3DZ(spectra) {\n        var minZ = spectra[0].data[0][0];\n        var maxZ = minZ;\n        var ySize = spectra.length;\n        var xSize = spectra[0].data[0].length / 2;\n        var z = new Array(ySize);\n        for (var i = 0; i < ySize; i++) {\n            z[i] = new Array(xSize);\n            var xVector = spectra[i].data[0];\n            for (var j = 0; j < xSize; j++) {\n                var value = xVector[j * 2 + 1];\n                z[i][j] = value;\n                if (value < minZ) minZ = value;\n                if (value > maxZ) maxZ = value;\n            }\n        }\n        return {\n            z: z,\n            minX: spectra[0].data[0][0],\n            maxX: spectra[0].data[0][spectra[0].data[0].length - 2], // has to be -2 because it is a 1D array [x,y,x,y,...]\n            minY: spectra[0].pageValue,\n            maxY: spectra[ySize - 1].pageValue,\n            minZ: minZ,\n            maxZ: maxZ,\n            noise: getMedian(z[0].map(Math.abs))\n        };\n\n    }\n\n    function add2D(result, options) {\n        var zData = convertTo3DZ(result.spectra);\n        if (!options.noContour) {\n            result.contourLines = generateContourLines(zData, options);\n            delete zData.z;\n        }\n        result.minMax = zData;\n    }\n\n\n    function generateContourLines(zData, options) {\n        var noise = zData.noise;\n        var z = zData.z;\n        var nbLevels = options.nbContourLevels || 7;\n        var noiseMultiplier = options.noiseMultiplier === undefined ? 5 : options.noiseMultiplier;\n        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n        var isOver0, isOver1, isOver2, isOver3;\n        var nbSubSpectra = z.length;\n        var nbPovars = z[0].length;\n        var pAx, pAy, pBx, pBy;\n\n        var x0 = zData.minX;\n        var xN = zData.maxX;\n        var dx = (xN - x0) / (nbPovars - 1);\n        var y0 = zData.minY;\n        var yN = zData.maxY;\n        var dy = (yN - y0) / (nbSubSpectra - 1);\n        var minZ = zData.minZ;\n        var maxZ = zData.maxZ;\n\n        //System.out.prvarln('y0 '+y0+' yN '+yN);\n        // -------------------------\n        // Povars attribution\n        //\n        // 0----1\n        // |  / |\n        // | /  |\n        // 2----3\n        //\n        // ---------------------d------\n\n        var iter = nbLevels * 2;\n        var contourLevels = new Array(iter);\n        var lineZValue;\n        for (var level = 0; level < iter; level++) { // multiply by 2 for positif and negatif\n            var contourLevel = {};\n            contourLevels[level] = contourLevel;\n            var side = level % 2;\n            var factor = (maxZ - noiseMultiplier * noise) * Math.exp((level >> 1) - nbLevels);\n            if (side === 0) {\n                lineZValue = factor + noiseMultiplier * noise;\n            } else {\n                lineZValue = (0 - factor) - noiseMultiplier * noise;\n            }\n            var lines = [];\n            contourLevel.zValue = lineZValue;\n            contourLevel.lines = lines;\n\n            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n                var subSpectra = z[iSubSpectra];\n                var subSpectraAfter = z[iSubSpectra + 1];\n                for (var povar = 0; povar < nbPovars - 1; povar++) {\n                    povarHeight0 = subSpectra[povar];\n                    povarHeight1 = subSpectra[povar + 1];\n                    povarHeight2 = subSpectraAfter[povar];\n                    povarHeight3 = subSpectraAfter[povar + 1];\n\n                    isOver0 = (povarHeight0 > lineZValue);\n                    isOver1 = (povarHeight1 > lineZValue);\n                    isOver2 = (povarHeight2 > lineZValue);\n                    isOver3 = (povarHeight3 > lineZValue);\n\n                    // Example povar0 is over the plane and povar1 and\n                    // povar2 are below, we find the varersections and add\n                    // the segment\n                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n                        pAy = iSubSpectra;\n                        pBx = povar;\n                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n                        lines.push(pAx * dx + x0);\n                        lines.push(pAy * dy + y0);\n                        lines.push(pBx * dx + x0);\n                        lines.push(pBy * dy + y0);\n                    }\n                    // remove push does not help !!!!\n                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n                        pAx = povar + 1;\n                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n                        pBy = iSubSpectra + 1;\n                        lines.push(pAx * dx + x0);\n                        lines.push(pAy * dy + y0);\n                        lines.push(pBx * dx + x0);\n                        lines.push(pBy * dy + y0);\n                    }\n                    // test around the diagonal\n                    if (isOver1 !== isOver2) {\n                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n                        if (isOver1 !== isOver0) {\n                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n                            pBy = iSubSpectra;\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver0) {\n                            pBx = povar;\n                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver1 !== isOver3) {\n                            pBx = povar + 1;\n                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver3) {\n                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n                            pBy = iSubSpectra + 1;\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                    }\n                }\n            }\n        }\n\n        return {\n            minX: zData.minX,\n            maxX: zData.maxX,\n            minY: zData.minY,\n            maxY: zData.maxY,\n            segments: contourLevels\n        };\n    }\n\n    function fastParseXYData(spectrum, value) {\n        // TODO need to deal with result\n        //  console.log(value);\n        // we check if deltaX is defined otherwise we calculate it\n\n        var yFactor = spectrum.yFactor;\n        var deltaX = spectrum.deltaX;\n\n\n        spectrum.isXYdata = true;\n        // TODO to be improved using 2 array {x:[], y:[]}\n        var currentData = [];\n        spectrum.data = [currentData];\n\n\n        var currentX = spectrum.firstX;\n        var currentY = spectrum.firstY;\n\n        // we skip the first line\n        //\n        var endLine = false;\n        for (var i = 0; i < value.length; i++) {\n            var ascii = value.charCodeAt(i);\n            if (ascii === 13 || ascii === 10) {\n                endLine = true;\n            } else {\n                if (endLine) break;\n            }\n        }\n\n        // we proceed taking the i after the first line\n        var newLine = true;\n        var isDifference = false;\n        var isLastDifference = false;\n        var lastDifference = 0;\n        var isDuplicate = false;\n        var inComment = false;\n        var currentValue = 0;\n        var isNegative = false;\n        var inValue = false;\n        var skipFirstValue = false;\n        var decimalPosition = 0;\n        var ascii;\n        for (; i <= value.length; i++) {\n            if (i === value.length) ascii = 13;\n            else ascii = value.charCodeAt(i);\n            if (inComment) {\n                // we should ignore the text if we are after $$\n                if (ascii === 13 || ascii === 10) {\n                    newLine = true;\n                    inComment = false;\n                }\n            } else {\n                // when is it a new value ?\n                // when it is not a digit, . or comma\n                // it is a number that is either new or we continue\n                if (ascii <= 57 && ascii >= 48) { // a number\n                    inValue = true;\n                    if (decimalPosition > 0) {\n                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n                    } else {\n                        currentValue *= 10;\n                        currentValue += ascii - 48;\n                    }\n                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n                    inValue = true;\n                    decimalPosition++;\n                } else {\n                    if (inValue) {\n                        // need to process the previous value\n                        if (newLine) {\n                            newLine = false; // we don't check the X value\n                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n                            // if new line and lastDifference, the first value is just a check !\n                            // that we don't check ...\n                            if (isLastDifference) skipFirstValue = true;\n                        } else {\n                            // need to deal with duplicate and differences\n                            if (skipFirstValue) {\n                                skipFirstValue = false;\n                            } else {\n                                if (isDifference) {\n                                    lastDifference = isNegative ? (0 - currentValue) : currentValue;\n                                    isLastDifference = true;\n                                    isDifference = false;\n                                }\n                                var duplicate = isDuplicate ? currentValue - 1 : 1;\n                                for (var j = 0; j < duplicate; j++) {\n                                    if (isLastDifference) {\n                                        currentY += lastDifference;\n                                    } else {\n                                        currentY = isNegative ? (0 - currentValue) : currentValue;\n                                    }\n                                    currentData.push(currentX);\n                                    currentData.push(currentY * yFactor);\n                                    currentX += deltaX;\n                                }\n                            }\n                        }\n                        isNegative = false;\n                        currentValue = 0;\n                        decimalPosition = 0;\n                        inValue = false;\n                        isDuplicate = false;\n                    }\n\n                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                    if ((ascii < 74) && (ascii > 63)) {\n                        inValue = true;\n                        isLastDifference = false;\n                        currentValue = ascii - 64;\n                    } else\n                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                    if ((ascii > 96) && (ascii < 106)) {\n                        inValue = true;\n                        isLastDifference = false;\n                        currentValue = ascii - 96;\n                        isNegative = true;\n                    } else\n                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                    if (ascii === 115) {\n                        inValue = true;\n                        isDuplicate = true;\n                        currentValue = 9;\n                    } else if ((ascii > 82) && (ascii < 91)) {\n                        inValue = true;\n                        isDuplicate = true;\n                        currentValue = ascii - 82;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if ((ascii > 73) && (ascii < 83)) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = ascii - 73;\n                    } else\n                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n                    if ((ascii > 105) && (ascii < 115)) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = ascii - 105;\n                        isNegative = true;\n                    } else\n                    // $ sign, we need to check the next one\n                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n                        inValue = true;\n                        inComment = true;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if (ascii === 37) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = 0;\n                        isNegative = false;\n                    } else if (ascii === 45) { // a \"-\"\n                        // check if after there is a number, decimal or comma\n                        var ascii2 = value.charCodeAt(i + 1);\n                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n                            inValue = true;\n                            isLastDifference = false;\n                            isNegative = true;\n                        }\n                    } else if (ascii === 13 || ascii === 10) {\n                        newLine = true;\n                        inComment = false;\n                    }\n                    // and now analyse the details ... space or tabulation\n                    // if \"+\" we just don't care\n                }\n            }\n        }\n    }\n\n    function parsePeakTable(spectrum, value, result) {\n        var removeCommentRegExp = /\\$\\$.*/;\n        var peakTableSplitRegExp = /[,\\t ]+/;\n\n        spectrum.isPeaktable = true;\n        var i, ii, j, jj, values;\n        var currentData = [];\n        spectrum.data = [currentData];\n\n        // counts for around 20% of the time\n        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n        for (i = 1, ii = lines.length; i < ii; i++) {\n            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n            if (values.length % 2 === 0) {\n                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n                    currentData.push(parseFloat(values[j]) * spectrum.xFactor);\n                    currentData.push(parseFloat(values[j + 1]) * spectrum.yFactor);\n                }\n            } else {\n                result.logs.push('Format error: ' + values);\n            }\n        }\n    }\n\n\n    return convert;\n\n}\n\nvar convert = getConverter();\n\nfunction JcampConverter(input, options, useWorker) {\n    if (typeof options === 'boolean') {\n        useWorker = options;\n        options = {};\n    }\n    if (useWorker) {\n        return postToWorker(input, options);\n    } else {\n        return convert(input, options);\n    }\n}\n\nvar stamps = {},\n    worker;\n\nfunction postToWorker(input, options) {\n    if (!worker) {\n        createWorker();\n    }\n    return new Promise(function (resolve) {\n        var stamp = Date.now() + '' + Math.random();\n        stamps[stamp] = resolve;\n        worker.postMessage(JSON.stringify({\n            stamp: stamp,\n            input: input,\n            options: options\n        }));\n    });\n}\n\nfunction createWorker() {\n    var workerURL = URL.createObjectURL(new Blob([\n        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { var data = JSON.parse(event.data); postMessage(JSON.stringify({stamp: data.stamp, output: convert(data.input, data.options)})); };'\n    ], {type: 'application/javascript'}));\n    worker = new Worker(workerURL);\n    URL.revokeObjectURL(workerURL);\n    worker.addEventListener('message', function (event) {\n        var data = JSON.parse(event.data);\n        var stamp = data.stamp;\n        if (stamps[stamp]) {\n            stamps[stamp](data.output);\n        }\n    });\n}\n\nmodule.exports = {\n    convert: JcampConverter\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\n\nvar xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\nvar removeCommentRegExp = /\\$\\$.*/;\nvar DEBUG=false;\n\nmodule.exports=function(spectrum, value, result) {\n    // we check if deltaX is defined otherwise we calculate it\n    if (!spectrum.deltaX) {\n        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n    }\n\n    spectrum.isXYdata=true;\n\n    var currentData = [];\n    var currentPosition=0;\n    spectrum.data = [currentData];\n\n    var currentX = spectrum.firstX;\n    var currentY = spectrum.firstY;\n    var lines = value.split(/[\\r\\n]+/);\n    var lastDif, values, ascii, expectedY;\n    values = [];\n    for (var i = 1, ii = lines.length; i < ii; i++) {\n        //var previousValues=JSON.parse(JSON.stringify(values));\n        values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n        if (values.length > 0) {\n            if (DEBUG) {\n                if (!spectrum.firstPoint) {\n                    spectrum.firstPoint = +values[0];\n                }\n                var expectedCurrentX = (values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n                if ((lastDif || lastDif === 0)) {\n                    expectedCurrentX += spectrum.deltaX;\n                }\n                result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n            }\n            for (var j = 1, jj = values.length; j < jj; j++) {\n                if (j === 1 && (lastDif || lastDif === 0)) {\n                    lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n                    // we could check if we have the expected Y value\n                    ascii = values[j].charCodeAt(0);\n\n                    if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n                        // + - . 0 1 2 3 4 5 6 7 8 9\n                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                            expectedY = +values[j];\n                        } else\n                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                        if ((ascii > 63) && (ascii < 74)) {\n                            expectedY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                        } else\n                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                        if ((ascii > 96) && (ascii < 106)) {\n                            expectedY = -(String.fromCharCode(ascii - 48) + values[j].substring(1));\n                        }\n                        if (expectedY !== currentY) {\n                            result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n                            result.logs.push('Previous values: ' + previousValues.length);\n                            result.logs.push(previousValues);\n                        }\n                    }\n                } else {\n                    if (values[j].length > 0) {\n                        ascii = values[j].charCodeAt(0);\n                        // + - . 0 1 2 3 4 5 6 7 8 9\n                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                            lastDif = null;\n                            currentY = +values[j];\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                        if ((ascii > 63) && (ascii < 74)) {\n                            lastDif = null;\n                            currentY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++] = currentX;\n                            currentData[currentPosition++] = currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                        if ((ascii > 96) && (ascii < 106)) {\n                            lastDif = null;\n                            // we can multiply the string by 1 because if may not contain decimal (is this correct ????)\n                            currentY = -(String.fromCharCode(ascii - 48) + values[j].substring(1))*1;\n                            //currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n\n\n\n                        // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                        if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n                            var dup = (String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n                            if (ascii === 115) {\n                                dup = ('9' + values[j].substring(1)) - 1;\n                            }\n                            for (var l = 0; l < dup; l++) {\n                                if (lastDif) {\n                                    currentY = currentY + lastDif;\n                                }\n                                // currentData.push(currentX, currentY * spectrum.yFactor);\n                                currentData[currentPosition++]=currentX;\n                                currentData[currentPosition++]=currentY * spectrum.yFactor;\n                                currentX += spectrum.deltaX;\n                            }\n                        } else\n                        // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                        if (ascii === 37) {\n                            lastDif = +('0' + values[j].substring(1));\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else if ((ascii > 73) && (ascii < 83)) {\n                            lastDif = (String.fromCharCode(ascii - 25) + values[j].substring(1))*1;\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // negative DIF digits j k l m n o p q r (ascii 106-114)\n                        if ((ascii > 105) && (ascii < 115)) {\n                            lastDif = -(String.fromCharCode(ascii - 57) + values[j].substring(1))*1;\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parseXYData.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}