{"version":3,"sources":["webpack:///jcampconverter/webpack/universalModuleDefinition","webpack:///jcampconverter/jcampconverter.min.js","webpack:///jcampconverter/webpack/bootstrap 414356469cb339dd4f23","webpack:///jcampconverter/./src/index.js","webpack:///jcampconverter/./src/parseXYData.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","getConverter","convertToFloatArray","stringArray","l","length","floatArray","Array","i","parseFloat","Spectrum","convert","jcamp","options","keepRecordsRegExp","ldr","dataLabel","dataValue","ldrs","ii","position","endLine","infos","start","Date","now","ntuples","result","profiling","logs","spectra","info","spectrum","push","action","time","split","replace","indexOf","substring","trim","toUpperCase","xIndex","yIndex","firstVariable","secondVariable","symbol","first","firstX","firstY","last","lastX","lastY","vardim","nbPoints","factor","xFactor","yFactor","units","xUnit","yUnit","datatable","deltaX","title","dataType","twoD","observeFrequency","xType","indirectFrequency","shiftOffsetNum","shiftOffsetVal","varname","ntuplesSeparator","vartype","varform","min","max","yType","page","pageValue","pageSymbol","pageSymbolIndex","unit","prepareSpectrum","match","fastParse","parseXYDataRegExp","fastParseXYData","parsePeakTable","isMSField","convertMSFieldToLabel","Object","keys","newNtuples","key","values","j","add2D","keepSpectra","isGCMS","newGCMS","xy","data","newData","x","y","k","addNewGCMS","addGCMS","value","toLowerCase","GC_MS_FIELDS","gcms","times","series","name","dimension","existingGCMSFields","label","gc","ms","shift","convertTo3DZ","noise","minZ","maxZ","ySize","xSize","z","xVector","Math","abs","minX","maxX","minY","maxY","zData","contourLines","generateContourLines","minMax","povarHeight0","povarHeight1","povarHeight2","povarHeight3","isOver0","isOver1","isOver2","isOver3","pAx","pAy","pBx","pBy","lineZValue","contourLevels","nbLevels","nbContourLevels","noiseMultiplier","undefined","nbSubSpectra","nbPovars","x0","xN","dx","y0","yN","dy","level","contourLevel","side","exp","lines","zValue","iSubSpectra","subSpectra","subSpectraAfter","povar","segments","isXYdata","currentData","currentPosition","currentX","currentY","ascii","charCodeAt","newLine","isDifference","isLastDifference","lastDifference","isDuplicate","inComment","currentValue","isNegative","inValue","skipFirstValue","decimalPosition","pow","duplicate","ascii2","removeCommentRegExp","peakTableSplitRegExp","isPeaktable","jj","JcampConverter","input","useWorker","postToWorker","worker","createWorker","Promise","resolve","stamp","random","stamps","postMessage","JSON","stringify","workerURL","URL","createObjectURL","Blob","toString","type","Worker","revokeObjectURL","addEventListener","event","parse","output","xyDataSplitRegExp","DEBUG","lastDif","firstPoint","expectedCurrentX","String","fromCharCode","dup"],"mappings":"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","file":"jcampconverter.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JcampConverter\"] = factory();\n\telse\n\t\troot[\"JcampConverter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JcampConverter\"] = factory();\n\telse\n\t\troot[\"JcampConverter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar parseXYDataRegExp = __webpack_require__(1);\n\t\n\t\n\tfunction getConverter() {\n\t\n\t    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n\t    var ntuplesSeparator = /[, \\t]{1,}/;\n\t\n\t    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\t\n\t    function convertToFloatArray(stringArray) {\n\t        var l = stringArray.length;\n\t        var floatArray = new Array(l);\n\t        for (var i = 0; i < l; i++) {\n\t            floatArray[i] = parseFloat(stringArray[i]);\n\t        }\n\t        return floatArray;\n\t    }\n\t    \n\t    function Spectrum() {\n\t        \n\t    }\n\t\n\t    /*\n\t     options.keepSpectra: keep the original spectra for a 2D\n\t     options.xy: true // create x / y array instead of a 1D array\n\t     options.keepRecordsRegExp: which fields do we keep\n\t     */\n\t\n\t    function convert(jcamp, options) {\n\t        options = options || {};\n\t\n\t        var keepRecordsRegExp = /^$/;\n\t        if (options.keepRecordsRegExp) keepRecordsRegExp = options.keepRecordsRegExp;\n\t\n\t        var start = Date.now();\n\t\n\t        var ntuples = {},\n\t            ldr,\n\t            dataLabel,\n\t            dataValue,\n\t            ldrs,\n\t            i, ii, position, endLine, infos;\n\t\n\t        var result = {};\n\t        result.profiling = [];\n\t        result.logs = [];\n\t        var spectra = [];\n\t        result.spectra = spectra;\n\t        result.info = {};\n\t        var spectrum = new Spectrum();\n\t\n\t        if (!(typeof jcamp === 'string')) return result;\n\t        // console.time('start');\n\t\n\t        if (result.profiling) result.profiling.push({\n\t            action: 'Before split to LDRS',\n\t            time: Date.now() - start\n\t        });\n\t\n\t        ldrs = jcamp.split(/[\\r\\n]+##/);\n\t\n\t        if (result.profiling) result.profiling.push({\n\t            action: 'Split to LDRS',\n\t            time: Date.now() - start\n\t        });\n\t\n\t        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\t\n\t        for (i = 0, ii = ldrs.length; i < ii; i++) {\n\t            ldr = ldrs[i];\n\t            // This is a new LDR\n\t            position = ldr.indexOf('=');\n\t            if (position > 0) {\n\t                dataLabel = ldr.substring(0, position);\n\t                dataValue = ldr.substring(position + 1).trim();\n\t            } else {\n\t                dataLabel = ldr;\n\t                dataValue = '';\n\t            }\n\t            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\t\n\t            if (dataLabel === 'DATATABLE') {\n\t                endLine = dataValue.indexOf('\\n');\n\t                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n\t                if (endLine > 0) {\n\t                    var xIndex = -1;\n\t                    var yIndex = -1;\n\t                    // ##DATA TABLE= (X++(I..I)), XYDATA\n\t                    // We need to find the variables\n\t\n\t                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n\t                    if (infos[0].indexOf('++') > 0) {\n\t                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n\t                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n\t                        xIndex = ntuples.symbol.indexOf(firstVariable);\n\t                        yIndex = ntuples.symbol.indexOf(secondVariable);\n\t                    }\n\t\n\t                    if (xIndex === -1) xIndex = 0;\n\t                    if (yIndex === -1) yIndex = 0;\n\t\n\t                    if (ntuples.first) {\n\t                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n\t                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n\t                    }\n\t                    if (ntuples.last) {\n\t                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n\t                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n\t                    }\n\t                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n\t                        spectrum.nbPoints = ntuples.vardim[xIndex];\n\t                    }\n\t                    if (ntuples.factor) {\n\t                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n\t                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n\t                    }\n\t                    if (ntuples.units) {\n\t                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n\t                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n\t                    }\n\t                    spectrum.datatable = infos[0];\n\t                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n\t                        dataLabel = 'PEAKTABLE';\n\t                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n\t                        dataLabel = 'XYDATA';\n\t                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t                    }\n\t                }\n\t            }\n\t\n\t\n\t            if (dataLabel === 'TITLE') {\n\t                spectrum.title = dataValue;\n\t            } else if (dataLabel === 'DATATYPE') {\n\t                spectrum.dataType = dataValue;\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'NTUPLES') {\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'XUNITS') {\n\t                spectrum.xUnit = dataValue;\n\t            } else if (dataLabel === 'YUNITS') {\n\t                spectrum.yUnit = dataValue;\n\t            } else if (dataLabel === 'FIRSTX') {\n\t                spectrum.firstX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTX') {\n\t                spectrum.lastX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'FIRSTY') {\n\t                spectrum.firstY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTY') {\n\t                spectrum.lastY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'NPOINTS') {\n\t                spectrum.nbPoints = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XFACTOR') {\n\t                spectrum.xFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'YFACTOR') {\n\t                spectrum.yFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'DELTAX') {\n\t                spectrum.deltaX = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n\t                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVENUCLEUS') {\n\t                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n\t            } else if (dataLabel === '$SFO2') {\n\t                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\t\n\t            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n\t                result.shiftOffsetNum = 0;\n\t                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n\t            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\t\n\t\n\t                // if we activate this part it does not work for ACD specmanager\n\t                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n\t                //                 var parts = dataValue.split(/ *, */);\n\t                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n\t                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n\t            } else if (dataLabel === 'VARNAME') {\n\t                ntuples.varname = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'SYMBOL') {\n\t                ntuples.symbol = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARTYPE') {\n\t                ntuples.vartype = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARFORM') {\n\t                ntuples.varform = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARDIM') {\n\t                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'UNITS') {\n\t                ntuples.units = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'FACTOR') {\n\t                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'FIRST') {\n\t                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'LAST') {\n\t                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'MIN') {\n\t                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'MAX') {\n\t                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === '.NUCLEUS') {\n\t                if (result.twoD) {\n\t                    result.yType = dataValue.split(ntuplesSeparator)[0];\n\t                }\n\t            } else if (dataLabel === 'PAGE') {\n\t                spectrum.page = dataValue.trim();\n\t                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n\t                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n\t                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n\t                var unit = '';\n\t                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n\t                    unit = ntuples.units[pageSymbolIndex];\n\t                }\n\t                if (result.indirectFrequency && unit !== 'PPM') {\n\t                    spectrum.pageValue /= result.indirectFrequency;\n\t                }\n\t            } else if (dataLabel === 'RETENTIONTIME') {\n\t                spectrum.pageValue = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XYDATA') {\n\t                prepareSpectrum(result, spectrum);\n\t                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n\t                if (dataValue.match(/.*\\+\\+.*/)) {\n\t                    if (options.fastParse === false) {\n\t                        parseXYDataRegExp(spectrum, dataValue, result);\n\t                    } else {\n\t                        if (!spectrum.deltaX) {\n\t                            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t                        }\n\t                        fastParseXYData(spectrum, dataValue, result);\n\t                    }\n\t                } else {\n\t                    parsePeakTable(spectrum, dataValue, result);\n\t                }\n\t                spectra.push(spectrum);\n\t                spectrum = new Spectrum();\n\t            } else if (dataLabel === 'PEAKTABLE') {\n\t                prepareSpectrum(result, spectrum);\n\t                parsePeakTable(spectrum, dataValue, result);\n\t                spectra.push(spectrum);\n\t                spectrum = new Spectrum();\n\t            } else if (isMSField(dataLabel)) {\n\t                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n\t            }\n\t            if (dataLabel.match(keepRecordsRegExp)) {\n\t                result.info[dataLabel] = dataValue.trim();\n\t            }\n\t        }\n\t\n\t        if (result.profiling) result.profiling.push({\n\t            action: 'Finished parsing',\n\t            time: Date.now() - start\n\t        });\n\t\n\t        if (Object.keys(ntuples).length > 0) {\n\t            var newNtuples = [];\n\t            var keys = Object.keys(ntuples);\n\t            for (var i = 0; i < keys.length; i++) {\n\t                var key = keys[i];\n\t                var values = ntuples[key];\n\t                for (var j = 0; j < values.length; j++) {\n\t                    if (!newNtuples[j]) newNtuples[j] = {};\n\t                    newNtuples[j][key] = values[j];\n\t                }\n\t            }\n\t            result.ntuples = newNtuples;\n\t        }\n\t\n\t        if (result.twoD) {\n\t            add2D(result, options);\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished countour plot calculation',\n\t                time: Date.now() - start\n\t            });\n\t            if (!options.keepSpectra) {\n\t                delete result.spectra;\n\t            }\n\t        }\n\t\n\t        var isGCMS = (spectra.length > 1 && (!spectra[0].dataType || spectra[0].dataType.match(/.*mass.*/i)));\n\t        if (isGCMS && options.newGCMS) {\n\t            options.xy = true;\n\t        }\n\t\n\t        if (options.xy) { // the spectraData should not be a oneD array but an object with x and y\n\t            if (spectra.length > 0) {\n\t                for (var i = 0; i < spectra.length; i++) {\n\t                    var spectrum = spectra[i];\n\t                    if (spectrum.data.length > 0) {\n\t                        for (var j = 0; j < spectrum.data.length; j++) {\n\t                            var data = spectrum.data[j];\n\t                            var newData = {\n\t                                x: new Array(data.length / 2),\n\t                                y: new Array(data.length / 2)\n\t                            };\n\t                            for (var k = 0; k < data.length; k = k + 2) {\n\t                                newData.x[k / 2] = data[k];\n\t                                newData.y[k / 2] = data[k + 1];\n\t                            }\n\t                            spectrum.data[j] = newData;\n\t                        }\n\t\n\t                    }\n\t\n\t                }\n\t            }\n\t        }\n\t\n\t        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n\t        if (isGCMS) {\n\t            if (options.newGCMS) {\n\t                addNewGCMS(result);\n\t            } else {\n\t                addGCMS(result);\n\t            }\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished GCMS calculation',\n\t                time: Date.now() - start\n\t            });\n\t        }\n\t\n\t        if (result.profiling) {\n\t            result.profiling.push({\n\t                action: 'Total time',\n\t                time: Date.now() - start\n\t            });\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t\n\t    function convertMSFieldToLabel(value) {\n\t        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n\t    }\n\t\n\t    function isMSField(dataLabel) {\n\t        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n\t    }\n\t\n\t    function addNewGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var length = spectra.length;\n\t        var gcms = {\n\t            times: new Array(length),\n\t            series: [{\n\t                name: 'ms',\n\t                dimension: 2,\n\t                data: new Array(length)\n\t            }]\n\t        };\n\t\n\t        var i;\n\t        var existingGCMSFields = [];\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t                gcms.series.push({\n\t                    name: label,\n\t                    dimension: 1,\n\t                    data: new Array(length)\n\t                });\n\t            }\n\t        }\n\t\n\t        for (i = 0; i < length; i++) {\n\t            var spectrum = spectra[i];\n\t            gcms.times[i] = spectrum.pageValue;\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.series[j + 1].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n\t            }\n\t            if (spectrum.data) {\n\t                gcms.series[0].data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n\t            }\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function addGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var existingGCMSFields = [];\n\t        var i;\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t            }\n\t        }\n\t        if (existingGCMSFields.length === 0) return;\n\t        var gcms = {};\n\t        gcms.gc = {};\n\t        gcms.ms = [];\n\t        for (i = 0; i < existingGCMSFields.length; i++) {\n\t            gcms.gc[existingGCMSFields[i]] = [];\n\t        }\n\t        for (i = 0; i < spectra.length; i++) {\n\t            var spectrum = spectra[i];\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n\t                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n\t            }\n\t            if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function prepareSpectrum(result, spectrum) {\n\t        if (!spectrum.xFactor) spectrum.xFactor = 1;\n\t        if (!spectrum.yFactor) spectrum.yFactor = 1;\n\t        if (spectrum.observeFrequency) {\n\t            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n\t                spectrum.xUnit = 'PPM';\n\t                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n\t                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n\t                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n\t                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n\t            }\n\t        }\n\t        if (result.shiftOffsetVal) {\n\t            var shift = spectrum.firstX - result.shiftOffsetVal;\n\t            spectrum.firstX = spectrum.firstX - shift;\n\t            spectrum.lastX = spectrum.lastX - shift;\n\t        }\n\t    }\n\t\n\t\n\t    function convertTo3DZ(spectra) {\n\t        var noise = 0;\n\t        var minZ = spectra[0].data[0][0];\n\t        var maxZ = minZ;\n\t        var ySize = spectra.length;\n\t        var xSize = spectra[0].data[0].length / 2;\n\t        var z = new Array(ySize);\n\t        for (var i = 0; i < ySize; i++) {\n\t            z[i] = new Array(xSize);\n\t            var xVector = spectra[i].data[0];\n\t            for (var j = 0; j < xSize; j++) {\n\t                var value = xVector[j * 2 + 1];\n\t                z[i][j] = value;\n\t                if (value < minZ) minZ = value;\n\t                if (value > maxZ) maxZ = value;\n\t                if (i !== 0 && j !== 0) {\n\t                    noise += Math.abs(value - z[i][j - 1]) + Math.abs(value - z[i - 1][j]);\n\t                }\n\t            }\n\t        }\n\t        return {\n\t            z: z,\n\t            minX: spectra[0].data[0][0],\n\t            maxX: spectra[0].data[0][spectra[0].data[0].length - 2], // has to be -2 because it is a 1D array [x,y,x,y,...]\n\t            minY: spectra[0].pageValue,\n\t            maxY: spectra[ySize - 1].pageValue,\n\t            minZ: minZ,\n\t            maxZ: maxZ,\n\t            noise: noise / ((ySize - 1) * (xSize - 1) * 2)\n\t        };\n\t\n\t    }\n\t\n\t    function add2D(result, options) {\n\t        var zData = convertTo3DZ(result.spectra);\n\t        result.contourLines = generateContourLines(zData, options);\n\t        delete zData.z;\n\t        result.minMax = zData;\n\t    }\n\t\n\t\n\t    function generateContourLines(zData, options) {\n\t        var noise = zData.noise;\n\t        var z = zData.z;\n\t        var contourLevels = [];\n\t        var nbLevels = options.nbContourLevels || 7;\n\t        var noiseMultiplier = options.noiseMultiplier === undefined ? 5 : options.noiseMultiplier;\n\t        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n\t        var isOver0, isOver1, isOver2, isOver3;\n\t        var nbSubSpectra = z.length;\n\t        var nbPovars = z[0].length;\n\t        var pAx, pAy, pBx, pBy;\n\t\n\t        var x0 = zData.minX;\n\t        var xN = zData.maxX;\n\t        var dx = (xN - x0) / (nbPovars - 1);\n\t        var y0 = zData.minY;\n\t        var yN = zData.maxY;\n\t        var dy = (yN - y0) / (nbSubSpectra - 1);\n\t        var minZ = zData.minZ;\n\t        var maxZ = zData.maxZ;\n\t\n\t        //System.out.prvarln('y0 '+y0+' yN '+yN);\n\t        // -------------------------\n\t        // Povars attribution\n\t        //\n\t        // 0----1\n\t        // |  / |\n\t        // | /  |\n\t        // 2----3\n\t        //\n\t        // ---------------------d------\n\t\n\t        var lineZValue;\n\t        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n\t            var contourLevel = {};\n\t            contourLevels[level] = contourLevel;\n\t            var side = level % 2;\n\t            var factor = (maxZ - noiseMultiplier * noise) * Math.exp(level >> 1 - nbLevels);\n\t            if (side === 0) {\n\t                lineZValue = factor + noiseMultiplier * noise;\n\t            } else {\n\t                lineZValue = -factor - noiseMultiplier * noise;\n\t            }\n\t            var lines = [];\n\t            contourLevel.zValue = lineZValue;\n\t            contourLevel.lines = lines;\n\t\n\t            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\t\n\t            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n\t                var subSpectra = z[iSubSpectra];\n\t                var subSpectraAfter = z[iSubSpectra + 1];\n\t                for (var povar = 0; povar < nbPovars - 1; povar++) {\n\t                    povarHeight0 = subSpectra[povar];\n\t                    povarHeight1 = subSpectra[povar + 1];\n\t                    povarHeight2 = subSpectraAfter[povar];\n\t                    povarHeight3 = subSpectraAfter[povar + 1];\n\t\n\t                    isOver0 = (povarHeight0 > lineZValue);\n\t                    isOver1 = (povarHeight1 > lineZValue);\n\t                    isOver2 = (povarHeight2 > lineZValue);\n\t                    isOver3 = (povarHeight3 > lineZValue);\n\t\n\t                    // Example povar0 is over the plane and povar1 and\n\t                    // povar2 are below, we find the varersections and add\n\t                    // the segment\n\t                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n\t                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n\t                        pAy = iSubSpectra;\n\t                        pBx = povar;\n\t                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n\t                        lines.push(pAx * dx + x0);\n\t                        lines.push(pAy * dy + y0);\n\t                        lines.push(pBx * dx + x0);\n\t                        lines.push(pBy * dy + y0);\n\t                    }\n\t                    // remove push does not help !!!!\n\t                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n\t                        pAx = povar + 1;\n\t                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n\t                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n\t                        pBy = iSubSpectra + 1;\n\t                        lines.push(pAx * dx + x0);\n\t                        lines.push(pAy * dy + y0);\n\t                        lines.push(pBx * dx + x0);\n\t                        lines.push(pBy * dy + y0);\n\t                    }\n\t                    // test around the diagonal\n\t                    if (isOver1 !== isOver2) {\n\t                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n\t                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n\t                        if (isOver1 !== isOver0) {\n\t                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n\t                            pBy = iSubSpectra;\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver2 !== isOver0) {\n\t                            pBx = povar;\n\t                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver1 !== isOver3) {\n\t                            pBx = povar + 1;\n\t                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver2 !== isOver3) {\n\t                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n\t                            pBy = iSubSpectra + 1;\n\t                            lines.push(pAx);\n\t                            lines.push(pAy);\n\t                            lines.push(pBx * dx + x0);\n\t                            lines.push(pBy * dy + y0);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        return {\n\t            minX: zData.minX,\n\t            maxX: zData.maxX,\n\t            minY: zData.minY,\n\t            maxY: zData.maxY,\n\t            segments: contourLevels\n\t        };\n\t    }\n\t\n\t    function fastParseXYData(spectrum, value) {\n\t        // TODO need to deal with result\n\t        //  console.log(value);\n\t        // we check if deltaX is defined otherwise we calculate it\n\t\n\t        var yFactor = spectrum.yFactor;\n\t        var deltaX = spectrum.deltaX;\n\t\n\t\n\t        spectrum.isXYdata = true;\n\t        // TODO to be improved using 2 array {x:[], y:[]}\n\t        var currentData = [];\n\t        var currentPosition = 0;\n\t        spectrum.data = [currentData];\n\t\n\t\n\t        var currentX = spectrum.firstX;\n\t        var currentY = spectrum.firstY;\n\t\n\t        // we skip the first line\n\t        //\n\t        var endLine = false;\n\t        for (var i = 0; i < value.length; i++) {\n\t            var ascii = value.charCodeAt(i);\n\t            if (ascii === 13 || ascii === 10) {\n\t                endLine = true;\n\t            } else {\n\t                if (endLine) break;\n\t            }\n\t        }\n\t\n\t        // we proceed taking the i after the first line\n\t        var newLine = true;\n\t        var isDifference = false;\n\t        var isLastDifference = false;\n\t        var lastDifference = 0;\n\t        var isDuplicate = false;\n\t        var inComment = false;\n\t        var currentValue = 0;\n\t        var isNegative = false;\n\t        var inValue = false;\n\t        var skipFirstValue = false;\n\t        var decimalPosition = 0;\n\t        var ascii;\n\t        for (; i <= value.length; i++) {\n\t            if (i === value.length) ascii = 13;\n\t            else ascii = value.charCodeAt(i);\n\t            if (inComment) {\n\t                // we should ignore the text if we are after $$\n\t                if (ascii === 13 || ascii === 10) {\n\t                    newLine = true;\n\t                    inComment = false;\n\t                }\n\t            } else {\n\t                // when is it a new value ?\n\t                // when it is not a digit, . or comma\n\t                // it is a number that is either new or we continue\n\t                if (ascii <= 57 && ascii >= 48) { // a number\n\t                    inValue = true;\n\t                    if (decimalPosition > 0) {\n\t                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n\t                    } else {\n\t                        currentValue *= 10;\n\t                        currentValue += ascii - 48;\n\t                    }\n\t                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n\t                    inValue = true;\n\t                    decimalPosition++;\n\t                } else {\n\t                    if (inValue) {\n\t                        // need to process the previous value\n\t                        if (newLine) {\n\t                            newLine = false; // we don't check the X value\n\t                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n\t                            // if new line and lastDifference, the first value is just a check !\n\t                            // that we don't check ...\n\t                            if (isLastDifference) skipFirstValue = true;\n\t                        } else {\n\t                            // need to deal with duplicate and differences\n\t                            if (skipFirstValue) {\n\t                                skipFirstValue = false;\n\t                            } else {\n\t                                if (isDifference) {\n\t                                    if (currentValue === 0) lastDifference = 0;\n\t                                    else lastDifference = isNegative ? -currentValue : currentValue;\n\t                                    isLastDifference = true;\n\t                                    isDifference = false;\n\t                                }\n\t                                var duplicate = isDuplicate ? currentValue - 1 : 1;\n\t                                for (var j = 0; j < duplicate; j++) {\n\t                                    if (isLastDifference) {\n\t                                        currentY += lastDifference;\n\t                                    } else {\n\t                                        if (currentValue === 0) currentY = 0;\n\t                                        else currentY = isNegative ? -currentValue : currentValue;\n\t                                    }\n\t\n\t                                    //  console.log(\"Separator\",isNegative ?\n\t                                    //          -currentValue : currentValue,\n\t                                    //      \"isDiff\", isDifference, \"isDup\", isDuplicate,\n\t                                    //      \"lastDif\", lastDifference, \"dup:\", duplicate, \"y\", currentY);\n\t\n\t                                    // push is slightly slower ... (we loose 10%)\n\t                                    currentData[currentPosition++] = currentX;\n\t                                    currentData[currentPosition++] = currentY * yFactor;\n\t                                    currentX += deltaX;\n\t                                }\n\t                            }\n\t                        }\n\t                        isNegative = false;\n\t                        currentValue = 0;\n\t                        decimalPosition = 0;\n\t                        inValue = false;\n\t                        isDuplicate = false;\n\t                    }\n\t\n\t                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                    if ((ascii < 74) && (ascii > 63)) {\n\t                        inValue = true;\n\t                        isLastDifference = false;\n\t                        currentValue = ascii - 64;\n\t                    } else\n\t                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                    if ((ascii > 96) && (ascii < 106)) {\n\t                        inValue = true;\n\t                        isLastDifference = false;\n\t                        currentValue = ascii - 96;\n\t                        isNegative = true;\n\t                    } else\n\t                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                    if (ascii === 115) {\n\t                        inValue = true;\n\t                        isDuplicate = true;\n\t                        currentValue = 9;\n\t                    } else if ((ascii > 82) && (ascii < 91)) {\n\t                        inValue = true;\n\t                        isDuplicate = true;\n\t                        currentValue = ascii - 82;\n\t                    } else\n\t                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                    if ((ascii > 73) && (ascii < 83)) {\n\t                        inValue = true;\n\t                        isDifference = true;\n\t                        currentValue = ascii - 73;\n\t                    } else\n\t                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                    if ((ascii > 105) && (ascii < 115)) {\n\t                        inValue = true;\n\t                        isDifference = true;\n\t                        currentValue = ascii - 105;\n\t                        isNegative = true;\n\t                    } else\n\t                    // $ sign, we need to check the next one\n\t                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n\t                        inValue = true;\n\t                        inComment = true;\n\t                    } else\n\t                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                    if (ascii === 37) {\n\t                        inValue = true;\n\t                        isDifference = true;\n\t                        currentValue = 0;\n\t                        isNegative = false;\n\t                    } else if (ascii === 45) { // a \"-\"\n\t                        // check if after there is a number, decimal or comma\n\t                        var ascii2 = value.charCodeAt(i + 1);\n\t                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n\t                            inValue = true;\n\t                            isLastDifference = false;\n\t                            isNegative = true;\n\t                        }\n\t                    } else if (ascii === 13 || ascii === 10) {\n\t                        newLine = true;\n\t                        inComment = false;\n\t                    }\n\t                    // and now analyse the details ... space or tabulation\n\t                    // if \"+\" we just don't care\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function parsePeakTable(spectrum, value, result) {\n\t        var removeCommentRegExp = /\\$\\$.*/;\n\t        var peakTableSplitRegExp = /[,\\t ]+/;\n\t\n\t        spectrum.isPeaktable = true;\n\t        var i, ii, j, jj, values;\n\t        var currentData = [];\n\t        spectrum.data = [currentData];\n\t\n\t        // counts for around 20% of the time\n\t        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\t\n\t        var k = 0;\n\t        for (i = 1, ii = lines.length; i < ii; i++) {\n\t            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n\t            if (values.length % 2 === 0) {\n\t                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n\t                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n\t                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n\t                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n\t                }\n\t            } else {\n\t                result.logs.push('Format error: ' + values);\n\t            }\n\t        }\n\t    }\n\t\n\t\n\t    return convert;\n\t\n\t}\n\t\n\tvar convert = getConverter();\n\t\n\tfunction JcampConverter(input, options, useWorker) {\n\t    if (typeof options === 'boolean') {\n\t        useWorker = options;\n\t        options = {};\n\t    }\n\t    if (useWorker) {\n\t        return postToWorker(input, options);\n\t    } else {\n\t        return convert(input, options);\n\t    }\n\t}\n\t\n\tvar stamps = {},\n\t    worker;\n\t\n\tfunction postToWorker(input, options) {\n\t    if (!worker) {\n\t        createWorker();\n\t    }\n\t    return new Promise(function (resolve) {\n\t        var stamp = Date.now() + '' + Math.random();\n\t        stamps[stamp] = resolve;\n\t        worker.postMessage(JSON.stringify({\n\t            stamp: stamp,\n\t            input: input,\n\t            options: options\n\t        }));\n\t    });\n\t}\n\t\n\tfunction createWorker() {\n\t    var workerURL = URL.createObjectURL(new Blob([\n\t        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { var data = JSON.parse(event.data); postMessage(JSON.stringify({stamp: data.stamp, output: convert(data.input, data.options)})); };'\n\t    ], {type: 'application/javascript'}));\n\t    worker = new Worker(workerURL);\n\t    URL.revokeObjectURL(workerURL);\n\t    worker.addEventListener('message', function (event) {\n\t        var data = JSON.parse(event.data);\n\t        var stamp = data.stamp;\n\t        if (stamps[stamp]) {\n\t            stamps[stamp](data.output);\n\t        }\n\t    });\n\t}\n\t\n\tmodule.exports = {\n\t    convert: JcampConverter\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\tvar xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\n\tvar removeCommentRegExp = /\\$\\$.*/;\n\tvar DEBUG=false;\n\t\n\tmodule.exports=function(spectrum, value, result) {\n\t    // we check if deltaX is defined otherwise we calculate it\n\t    if (!spectrum.deltaX) {\n\t        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t    }\n\t\n\t    spectrum.isXYdata=true;\n\t\n\t    var currentData = [];\n\t    var currentPosition=0;\n\t    spectrum.data = [currentData];\n\t\n\t    var currentX = spectrum.firstX;\n\t    var currentY = spectrum.firstY;\n\t    var lines = value.split(/[\\r\\n]+/);\n\t    var lastDif, values, ascii, expectedY;\n\t    values = [];\n\t    for (var i = 1, ii = lines.length; i < ii; i++) {\n\t        //var previousValues=JSON.parse(JSON.stringify(values));\n\t        values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n\t        if (values.length > 0) {\n\t            if (DEBUG) {\n\t                if (!spectrum.firstPoint) {\n\t                    spectrum.firstPoint = +values[0];\n\t                }\n\t                var expectedCurrentX = (values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n\t                if ((lastDif || lastDif === 0)) {\n\t                    expectedCurrentX += spectrum.deltaX;\n\t                }\n\t                result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n\t            }\n\t            for (var j = 1, jj = values.length; j < jj; j++) {\n\t                if (j === 1 && (lastDif || lastDif === 0)) {\n\t                    lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n\t                    // we could check if we have the expected Y value\n\t                    ascii = values[j].charCodeAt(0);\n\t\n\t                    if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n\t                        // + - . 0 1 2 3 4 5 6 7 8 9\n\t                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                            expectedY = +values[j];\n\t                        } else\n\t                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                        if ((ascii > 63) && (ascii < 74)) {\n\t                            expectedY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                        } else\n\t                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                        if ((ascii > 96) && (ascii < 106)) {\n\t                            expectedY = -(String.fromCharCode(ascii - 48) + values[j].substring(1));\n\t                        }\n\t                        if (expectedY !== currentY) {\n\t                            result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n\t                            result.logs.push('Previous values: ' + previousValues.length);\n\t                            result.logs.push(previousValues);\n\t                        }\n\t                    }\n\t                } else {\n\t                    if (values[j].length > 0) {\n\t                        ascii = values[j].charCodeAt(0);\n\t                        // + - . 0 1 2 3 4 5 6 7 8 9\n\t                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                            lastDif = null;\n\t                            currentY = +values[j];\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                        if ((ascii > 63) && (ascii < 74)) {\n\t                            lastDif = null;\n\t                            currentY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++] = currentX;\n\t                            currentData[currentPosition++] = currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                        if ((ascii > 96) && (ascii < 106)) {\n\t                            lastDif = null;\n\t                            // we can multiply the string by 1 because if may not contain decimal (is this correct ????)\n\t                            currentY = -(String.fromCharCode(ascii - 48) + values[j].substring(1))*1;\n\t                            //currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t\n\t\n\t\n\t                        // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                        if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n\t                            var dup = (String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n\t                            if (ascii === 115) {\n\t                                dup = ('9' + values[j].substring(1)) - 1;\n\t                            }\n\t                            for (var l = 0; l < dup; l++) {\n\t                                if (lastDif) {\n\t                                    currentY = currentY + lastDif;\n\t                                }\n\t                                // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                                currentData[currentPosition++]=currentX;\n\t                                currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                                currentX += spectrum.deltaX;\n\t                            }\n\t                        } else\n\t                        // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                        if (ascii === 37) {\n\t                            lastDif = +('0' + values[j].substring(1));\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else if ((ascii > 73) && (ascii < 83)) {\n\t                            lastDif = (String.fromCharCode(ascii - 25) + values[j].substring(1))*1;\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                        if ((ascii > 105) && (ascii < 115)) {\n\t                            lastDif = -(String.fromCharCode(ascii - 57) + values[j].substring(1))*1;\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** jcampconverter.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 414356469cb339dd4f23\n **/","'use strict';\n\nvar parseXYDataRegExp = require('./parseXYData.js');\n\n\nfunction getConverter() {\n\n    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n    var ntuplesSeparator = /[, \\t]{1,}/;\n\n    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\n    function convertToFloatArray(stringArray) {\n        var l = stringArray.length;\n        var floatArray = new Array(l);\n        for (var i = 0; i < l; i++) {\n            floatArray[i] = parseFloat(stringArray[i]);\n        }\n        return floatArray;\n    }\n    \n    function Spectrum() {\n        \n    }\n\n    /*\n     options.keepSpectra: keep the original spectra for a 2D\n     options.xy: true // create x / y array instead of a 1D array\n     options.keepRecordsRegExp: which fields do we keep\n     */\n\n    function convert(jcamp, options) {\n        options = options || {};\n\n        var keepRecordsRegExp = /^$/;\n        if (options.keepRecordsRegExp) keepRecordsRegExp = options.keepRecordsRegExp;\n\n        var start = Date.now();\n\n        var ntuples = {},\n            ldr,\n            dataLabel,\n            dataValue,\n            ldrs,\n            i, ii, position, endLine, infos;\n\n        var result = {};\n        result.profiling = [];\n        result.logs = [];\n        var spectra = [];\n        result.spectra = spectra;\n        result.info = {};\n        var spectrum = new Spectrum();\n\n        if (!(typeof jcamp === 'string')) return result;\n        // console.time('start');\n\n        if (result.profiling) result.profiling.push({\n            action: 'Before split to LDRS',\n            time: Date.now() - start\n        });\n\n        ldrs = jcamp.split(/[\\r\\n]+##/);\n\n        if (result.profiling) result.profiling.push({\n            action: 'Split to LDRS',\n            time: Date.now() - start\n        });\n\n        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n        for (i = 0, ii = ldrs.length; i < ii; i++) {\n            ldr = ldrs[i];\n            // This is a new LDR\n            position = ldr.indexOf('=');\n            if (position > 0) {\n                dataLabel = ldr.substring(0, position);\n                dataValue = ldr.substring(position + 1).trim();\n            } else {\n                dataLabel = ldr;\n                dataValue = '';\n            }\n            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n            if (dataLabel === 'DATATABLE') {\n                endLine = dataValue.indexOf('\\n');\n                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n                if (endLine > 0) {\n                    var xIndex = -1;\n                    var yIndex = -1;\n                    // ##DATA TABLE= (X++(I..I)), XYDATA\n                    // We need to find the variables\n\n                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n                    if (infos[0].indexOf('++') > 0) {\n                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n                        xIndex = ntuples.symbol.indexOf(firstVariable);\n                        yIndex = ntuples.symbol.indexOf(secondVariable);\n                    }\n\n                    if (xIndex === -1) xIndex = 0;\n                    if (yIndex === -1) yIndex = 0;\n\n                    if (ntuples.first) {\n                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n                    }\n                    if (ntuples.last) {\n                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n                    }\n                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n                        spectrum.nbPoints = ntuples.vardim[xIndex];\n                    }\n                    if (ntuples.factor) {\n                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n                    }\n                    if (ntuples.units) {\n                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n                    }\n                    spectrum.datatable = infos[0];\n                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n                        dataLabel = 'PEAKTABLE';\n                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n                        dataLabel = 'XYDATA';\n                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                    }\n                }\n            }\n\n\n            if (dataLabel === 'TITLE') {\n                spectrum.title = dataValue;\n            } else if (dataLabel === 'DATATYPE') {\n                spectrum.dataType = dataValue;\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'NTUPLES') {\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'XUNITS') {\n                spectrum.xUnit = dataValue;\n            } else if (dataLabel === 'YUNITS') {\n                spectrum.yUnit = dataValue;\n            } else if (dataLabel === 'FIRSTX') {\n                spectrum.firstX = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTX') {\n                spectrum.lastX = parseFloat(dataValue);\n            } else if (dataLabel === 'FIRSTY') {\n                spectrum.firstY = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTY') {\n                spectrum.lastY = parseFloat(dataValue);\n            } else if (dataLabel === 'NPOINTS') {\n                spectrum.nbPoints = parseFloat(dataValue);\n            } else if (dataLabel === 'XFACTOR') {\n                spectrum.xFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'YFACTOR') {\n                spectrum.yFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'DELTAX') {\n                spectrum.deltaX = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVENUCLEUS') {\n                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n            } else if (dataLabel === '$SFO2') {\n                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\n            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n                result.shiftOffsetNum = 0;\n                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\n\n                // if we activate this part it does not work for ACD specmanager\n                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n                //                 var parts = dataValue.split(/ *, */);\n                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n            } else if (dataLabel === 'VARNAME') {\n                ntuples.varname = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'SYMBOL') {\n                ntuples.symbol = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARTYPE') {\n                ntuples.vartype = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARFORM') {\n                ntuples.varform = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARDIM') {\n                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'UNITS') {\n                ntuples.units = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'FACTOR') {\n                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'FIRST') {\n                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'LAST') {\n                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MIN') {\n                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MAX') {\n                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === '.NUCLEUS') {\n                if (result.twoD) {\n                    result.yType = dataValue.split(ntuplesSeparator)[0];\n                }\n            } else if (dataLabel === 'PAGE') {\n                spectrum.page = dataValue.trim();\n                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n                var unit = '';\n                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n                    unit = ntuples.units[pageSymbolIndex];\n                }\n                if (result.indirectFrequency && unit !== 'PPM') {\n                    spectrum.pageValue /= result.indirectFrequency;\n                }\n            } else if (dataLabel === 'RETENTIONTIME') {\n                spectrum.pageValue = parseFloat(dataValue);\n            } else if (dataLabel === 'XYDATA') {\n                prepareSpectrum(result, spectrum);\n                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n                if (dataValue.match(/.*\\+\\+.*/)) {\n                    if (options.fastParse === false) {\n                        parseXYDataRegExp(spectrum, dataValue, result);\n                    } else {\n                        if (!spectrum.deltaX) {\n                            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                        }\n                        fastParseXYData(spectrum, dataValue, result);\n                    }\n                } else {\n                    parsePeakTable(spectrum, dataValue, result);\n                }\n                spectra.push(spectrum);\n                spectrum = new Spectrum();\n            } else if (dataLabel === 'PEAKTABLE') {\n                prepareSpectrum(result, spectrum);\n                parsePeakTable(spectrum, dataValue, result);\n                spectra.push(spectrum);\n                spectrum = new Spectrum();\n            } else if (isMSField(dataLabel)) {\n                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n            }\n            if (dataLabel.match(keepRecordsRegExp)) {\n                result.info[dataLabel] = dataValue.trim();\n            }\n        }\n\n        if (result.profiling) result.profiling.push({\n            action: 'Finished parsing',\n            time: Date.now() - start\n        });\n\n        if (Object.keys(ntuples).length > 0) {\n            var newNtuples = [];\n            var keys = Object.keys(ntuples);\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var values = ntuples[key];\n                for (var j = 0; j < values.length; j++) {\n                    if (!newNtuples[j]) newNtuples[j] = {};\n                    newNtuples[j][key] = values[j];\n                }\n            }\n            result.ntuples = newNtuples;\n        }\n\n        if (result.twoD) {\n            add2D(result, options);\n            if (result.profiling) result.profiling.push({\n                action: 'Finished countour plot calculation',\n                time: Date.now() - start\n            });\n            if (!options.keepSpectra) {\n                delete result.spectra;\n            }\n        }\n\n        var isGCMS = (spectra.length > 1 && (!spectra[0].dataType || spectra[0].dataType.match(/.*mass.*/i)));\n        if (isGCMS && options.newGCMS) {\n            options.xy = true;\n        }\n\n        if (options.xy) { // the spectraData should not be a oneD array but an object with x and y\n            if (spectra.length > 0) {\n                for (var i = 0; i < spectra.length; i++) {\n                    var spectrum = spectra[i];\n                    if (spectrum.data.length > 0) {\n                        for (var j = 0; j < spectrum.data.length; j++) {\n                            var data = spectrum.data[j];\n                            var newData = {\n                                x: new Array(data.length / 2),\n                                y: new Array(data.length / 2)\n                            };\n                            for (var k = 0; k < data.length; k = k + 2) {\n                                newData.x[k / 2] = data[k];\n                                newData.y[k / 2] = data[k + 1];\n                            }\n                            spectrum.data[j] = newData;\n                        }\n\n                    }\n\n                }\n            }\n        }\n\n        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n        if (isGCMS) {\n            if (options.newGCMS) {\n                addNewGCMS(result);\n            } else {\n                addGCMS(result);\n            }\n            if (result.profiling) result.profiling.push({\n                action: 'Finished GCMS calculation',\n                time: Date.now() - start\n            });\n        }\n\n        if (result.profiling) {\n            result.profiling.push({\n                action: 'Total time',\n                time: Date.now() - start\n            });\n        }\n\n        return result;\n    }\n\n\n    function convertMSFieldToLabel(value) {\n        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n    }\n\n    function isMSField(dataLabel) {\n        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n    }\n\n    function addNewGCMS(result) {\n        var spectra = result.spectra;\n        var length = spectra.length;\n        var gcms = {\n            times: new Array(length),\n            series: [{\n                name: 'ms',\n                dimension: 2,\n                data: new Array(length)\n            }]\n        };\n\n        var i;\n        var existingGCMSFields = [];\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n                gcms.series.push({\n                    name: label,\n                    dimension: 1,\n                    data: new Array(length)\n                });\n            }\n        }\n\n        for (i = 0; i < length; i++) {\n            var spectrum = spectra[i];\n            gcms.times[i] = spectrum.pageValue;\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.series[j + 1].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n            }\n            if (spectrum.data) {\n                gcms.series[0].data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n            }\n\n        }\n        result.gcms = gcms;\n    }\n\n    function addGCMS(result) {\n        var spectra = result.spectra;\n        var existingGCMSFields = [];\n        var i;\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n            }\n        }\n        if (existingGCMSFields.length === 0) return;\n        var gcms = {};\n        gcms.gc = {};\n        gcms.ms = [];\n        for (i = 0; i < existingGCMSFields.length; i++) {\n            gcms.gc[existingGCMSFields[i]] = [];\n        }\n        for (i = 0; i < spectra.length; i++) {\n            var spectrum = spectra[i];\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n            }\n            if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\n        }\n        result.gcms = gcms;\n    }\n\n    function prepareSpectrum(result, spectrum) {\n        if (!spectrum.xFactor) spectrum.xFactor = 1;\n        if (!spectrum.yFactor) spectrum.yFactor = 1;\n        if (spectrum.observeFrequency) {\n            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n                spectrum.xUnit = 'PPM';\n                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n            }\n        }\n        if (result.shiftOffsetVal) {\n            var shift = spectrum.firstX - result.shiftOffsetVal;\n            spectrum.firstX = spectrum.firstX - shift;\n            spectrum.lastX = spectrum.lastX - shift;\n        }\n    }\n\n\n    function convertTo3DZ(spectra) {\n        var noise = 0;\n        var minZ = spectra[0].data[0][0];\n        var maxZ = minZ;\n        var ySize = spectra.length;\n        var xSize = spectra[0].data[0].length / 2;\n        var z = new Array(ySize);\n        for (var i = 0; i < ySize; i++) {\n            z[i] = new Array(xSize);\n            var xVector = spectra[i].data[0];\n            for (var j = 0; j < xSize; j++) {\n                var value = xVector[j * 2 + 1];\n                z[i][j] = value;\n                if (value < minZ) minZ = value;\n                if (value > maxZ) maxZ = value;\n                if (i !== 0 && j !== 0) {\n                    noise += Math.abs(value - z[i][j - 1]) + Math.abs(value - z[i - 1][j]);\n                }\n            }\n        }\n        return {\n            z: z,\n            minX: spectra[0].data[0][0],\n            maxX: spectra[0].data[0][spectra[0].data[0].length - 2], // has to be -2 because it is a 1D array [x,y,x,y,...]\n            minY: spectra[0].pageValue,\n            maxY: spectra[ySize - 1].pageValue,\n            minZ: minZ,\n            maxZ: maxZ,\n            noise: noise / ((ySize - 1) * (xSize - 1) * 2)\n        };\n\n    }\n\n    function add2D(result, options) {\n        var zData = convertTo3DZ(result.spectra);\n        result.contourLines = generateContourLines(zData, options);\n        delete zData.z;\n        result.minMax = zData;\n    }\n\n\n    function generateContourLines(zData, options) {\n        var noise = zData.noise;\n        var z = zData.z;\n        var contourLevels = [];\n        var nbLevels = options.nbContourLevels || 7;\n        var noiseMultiplier = options.noiseMultiplier === undefined ? 5 : options.noiseMultiplier;\n        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n        var isOver0, isOver1, isOver2, isOver3;\n        var nbSubSpectra = z.length;\n        var nbPovars = z[0].length;\n        var pAx, pAy, pBx, pBy;\n\n        var x0 = zData.minX;\n        var xN = zData.maxX;\n        var dx = (xN - x0) / (nbPovars - 1);\n        var y0 = zData.minY;\n        var yN = zData.maxY;\n        var dy = (yN - y0) / (nbSubSpectra - 1);\n        var minZ = zData.minZ;\n        var maxZ = zData.maxZ;\n\n        //System.out.prvarln('y0 '+y0+' yN '+yN);\n        // -------------------------\n        // Povars attribution\n        //\n        // 0----1\n        // |  / |\n        // | /  |\n        // 2----3\n        //\n        // ---------------------d------\n\n        var lineZValue;\n        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n            var contourLevel = {};\n            contourLevels[level] = contourLevel;\n            var side = level % 2;\n            var factor = (maxZ - noiseMultiplier * noise) * Math.exp(level >> 1 - nbLevels);\n            if (side === 0) {\n                lineZValue = factor + noiseMultiplier * noise;\n            } else {\n                lineZValue = -factor - noiseMultiplier * noise;\n            }\n            var lines = [];\n            contourLevel.zValue = lineZValue;\n            contourLevel.lines = lines;\n\n            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n                var subSpectra = z[iSubSpectra];\n                var subSpectraAfter = z[iSubSpectra + 1];\n                for (var povar = 0; povar < nbPovars - 1; povar++) {\n                    povarHeight0 = subSpectra[povar];\n                    povarHeight1 = subSpectra[povar + 1];\n                    povarHeight2 = subSpectraAfter[povar];\n                    povarHeight3 = subSpectraAfter[povar + 1];\n\n                    isOver0 = (povarHeight0 > lineZValue);\n                    isOver1 = (povarHeight1 > lineZValue);\n                    isOver2 = (povarHeight2 > lineZValue);\n                    isOver3 = (povarHeight3 > lineZValue);\n\n                    // Example povar0 is over the plane and povar1 and\n                    // povar2 are below, we find the varersections and add\n                    // the segment\n                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n                        pAy = iSubSpectra;\n                        pBx = povar;\n                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n                        lines.push(pAx * dx + x0);\n                        lines.push(pAy * dy + y0);\n                        lines.push(pBx * dx + x0);\n                        lines.push(pBy * dy + y0);\n                    }\n                    // remove push does not help !!!!\n                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n                        pAx = povar + 1;\n                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n                        pBy = iSubSpectra + 1;\n                        lines.push(pAx * dx + x0);\n                        lines.push(pAy * dy + y0);\n                        lines.push(pBx * dx + x0);\n                        lines.push(pBy * dy + y0);\n                    }\n                    // test around the diagonal\n                    if (isOver1 !== isOver2) {\n                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n                        if (isOver1 !== isOver0) {\n                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n                            pBy = iSubSpectra;\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver0) {\n                            pBx = povar;\n                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver1 !== isOver3) {\n                            pBx = povar + 1;\n                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver3) {\n                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n                            pBy = iSubSpectra + 1;\n                            lines.push(pAx);\n                            lines.push(pAy);\n                            lines.push(pBx * dx + x0);\n                            lines.push(pBy * dy + y0);\n                        }\n                    }\n                }\n            }\n        }\n\n        return {\n            minX: zData.minX,\n            maxX: zData.maxX,\n            minY: zData.minY,\n            maxY: zData.maxY,\n            segments: contourLevels\n        };\n    }\n\n    function fastParseXYData(spectrum, value) {\n        // TODO need to deal with result\n        //  console.log(value);\n        // we check if deltaX is defined otherwise we calculate it\n\n        var yFactor = spectrum.yFactor;\n        var deltaX = spectrum.deltaX;\n\n\n        spectrum.isXYdata = true;\n        // TODO to be improved using 2 array {x:[], y:[]}\n        var currentData = [];\n        var currentPosition = 0;\n        spectrum.data = [currentData];\n\n\n        var currentX = spectrum.firstX;\n        var currentY = spectrum.firstY;\n\n        // we skip the first line\n        //\n        var endLine = false;\n        for (var i = 0; i < value.length; i++) {\n            var ascii = value.charCodeAt(i);\n            if (ascii === 13 || ascii === 10) {\n                endLine = true;\n            } else {\n                if (endLine) break;\n            }\n        }\n\n        // we proceed taking the i after the first line\n        var newLine = true;\n        var isDifference = false;\n        var isLastDifference = false;\n        var lastDifference = 0;\n        var isDuplicate = false;\n        var inComment = false;\n        var currentValue = 0;\n        var isNegative = false;\n        var inValue = false;\n        var skipFirstValue = false;\n        var decimalPosition = 0;\n        var ascii;\n        for (; i <= value.length; i++) {\n            if (i === value.length) ascii = 13;\n            else ascii = value.charCodeAt(i);\n            if (inComment) {\n                // we should ignore the text if we are after $$\n                if (ascii === 13 || ascii === 10) {\n                    newLine = true;\n                    inComment = false;\n                }\n            } else {\n                // when is it a new value ?\n                // when it is not a digit, . or comma\n                // it is a number that is either new or we continue\n                if (ascii <= 57 && ascii >= 48) { // a number\n                    inValue = true;\n                    if (decimalPosition > 0) {\n                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n                    } else {\n                        currentValue *= 10;\n                        currentValue += ascii - 48;\n                    }\n                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n                    inValue = true;\n                    decimalPosition++;\n                } else {\n                    if (inValue) {\n                        // need to process the previous value\n                        if (newLine) {\n                            newLine = false; // we don't check the X value\n                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n                            // if new line and lastDifference, the first value is just a check !\n                            // that we don't check ...\n                            if (isLastDifference) skipFirstValue = true;\n                        } else {\n                            // need to deal with duplicate and differences\n                            if (skipFirstValue) {\n                                skipFirstValue = false;\n                            } else {\n                                if (isDifference) {\n                                    if (currentValue === 0) lastDifference = 0;\n                                    else lastDifference = isNegative ? -currentValue : currentValue;\n                                    isLastDifference = true;\n                                    isDifference = false;\n                                }\n                                var duplicate = isDuplicate ? currentValue - 1 : 1;\n                                for (var j = 0; j < duplicate; j++) {\n                                    if (isLastDifference) {\n                                        currentY += lastDifference;\n                                    } else {\n                                        if (currentValue === 0) currentY = 0;\n                                        else currentY = isNegative ? -currentValue : currentValue;\n                                    }\n\n                                    //  console.log(\"Separator\",isNegative ?\n                                    //          -currentValue : currentValue,\n                                    //      \"isDiff\", isDifference, \"isDup\", isDuplicate,\n                                    //      \"lastDif\", lastDifference, \"dup:\", duplicate, \"y\", currentY);\n\n                                    // push is slightly slower ... (we loose 10%)\n                                    currentData[currentPosition++] = currentX;\n                                    currentData[currentPosition++] = currentY * yFactor;\n                                    currentX += deltaX;\n                                }\n                            }\n                        }\n                        isNegative = false;\n                        currentValue = 0;\n                        decimalPosition = 0;\n                        inValue = false;\n                        isDuplicate = false;\n                    }\n\n                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                    if ((ascii < 74) && (ascii > 63)) {\n                        inValue = true;\n                        isLastDifference = false;\n                        currentValue = ascii - 64;\n                    } else\n                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                    if ((ascii > 96) && (ascii < 106)) {\n                        inValue = true;\n                        isLastDifference = false;\n                        currentValue = ascii - 96;\n                        isNegative = true;\n                    } else\n                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                    if (ascii === 115) {\n                        inValue = true;\n                        isDuplicate = true;\n                        currentValue = 9;\n                    } else if ((ascii > 82) && (ascii < 91)) {\n                        inValue = true;\n                        isDuplicate = true;\n                        currentValue = ascii - 82;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if ((ascii > 73) && (ascii < 83)) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = ascii - 73;\n                    } else\n                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n                    if ((ascii > 105) && (ascii < 115)) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = ascii - 105;\n                        isNegative = true;\n                    } else\n                    // $ sign, we need to check the next one\n                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n                        inValue = true;\n                        inComment = true;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if (ascii === 37) {\n                        inValue = true;\n                        isDifference = true;\n                        currentValue = 0;\n                        isNegative = false;\n                    } else if (ascii === 45) { // a \"-\"\n                        // check if after there is a number, decimal or comma\n                        var ascii2 = value.charCodeAt(i + 1);\n                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n                            inValue = true;\n                            isLastDifference = false;\n                            isNegative = true;\n                        }\n                    } else if (ascii === 13 || ascii === 10) {\n                        newLine = true;\n                        inComment = false;\n                    }\n                    // and now analyse the details ... space or tabulation\n                    // if \"+\" we just don't care\n                }\n            }\n        }\n    }\n\n    function parsePeakTable(spectrum, value, result) {\n        var removeCommentRegExp = /\\$\\$.*/;\n        var peakTableSplitRegExp = /[,\\t ]+/;\n\n        spectrum.isPeaktable = true;\n        var i, ii, j, jj, values;\n        var currentData = [];\n        spectrum.data = [currentData];\n\n        // counts for around 20% of the time\n        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n        var k = 0;\n        for (i = 1, ii = lines.length; i < ii; i++) {\n            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n            if (values.length % 2 === 0) {\n                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n                }\n            } else {\n                result.logs.push('Format error: ' + values);\n            }\n        }\n    }\n\n\n    return convert;\n\n}\n\nvar convert = getConverter();\n\nfunction JcampConverter(input, options, useWorker) {\n    if (typeof options === 'boolean') {\n        useWorker = options;\n        options = {};\n    }\n    if (useWorker) {\n        return postToWorker(input, options);\n    } else {\n        return convert(input, options);\n    }\n}\n\nvar stamps = {},\n    worker;\n\nfunction postToWorker(input, options) {\n    if (!worker) {\n        createWorker();\n    }\n    return new Promise(function (resolve) {\n        var stamp = Date.now() + '' + Math.random();\n        stamps[stamp] = resolve;\n        worker.postMessage(JSON.stringify({\n            stamp: stamp,\n            input: input,\n            options: options\n        }));\n    });\n}\n\nfunction createWorker() {\n    var workerURL = URL.createObjectURL(new Blob([\n        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { var data = JSON.parse(event.data); postMessage(JSON.stringify({stamp: data.stamp, output: convert(data.input, data.options)})); };'\n    ], {type: 'application/javascript'}));\n    worker = new Worker(workerURL);\n    URL.revokeObjectURL(workerURL);\n    worker.addEventListener('message', function (event) {\n        var data = JSON.parse(event.data);\n        var stamp = data.stamp;\n        if (stamps[stamp]) {\n            stamps[stamp](data.output);\n        }\n    });\n}\n\nmodule.exports = {\n    convert: JcampConverter\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\n\nvar xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\nvar removeCommentRegExp = /\\$\\$.*/;\nvar DEBUG=false;\n\nmodule.exports=function(spectrum, value, result) {\n    // we check if deltaX is defined otherwise we calculate it\n    if (!spectrum.deltaX) {\n        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n    }\n\n    spectrum.isXYdata=true;\n\n    var currentData = [];\n    var currentPosition=0;\n    spectrum.data = [currentData];\n\n    var currentX = spectrum.firstX;\n    var currentY = spectrum.firstY;\n    var lines = value.split(/[\\r\\n]+/);\n    var lastDif, values, ascii, expectedY;\n    values = [];\n    for (var i = 1, ii = lines.length; i < ii; i++) {\n        //var previousValues=JSON.parse(JSON.stringify(values));\n        values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n        if (values.length > 0) {\n            if (DEBUG) {\n                if (!spectrum.firstPoint) {\n                    spectrum.firstPoint = +values[0];\n                }\n                var expectedCurrentX = (values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n                if ((lastDif || lastDif === 0)) {\n                    expectedCurrentX += spectrum.deltaX;\n                }\n                result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n            }\n            for (var j = 1, jj = values.length; j < jj; j++) {\n                if (j === 1 && (lastDif || lastDif === 0)) {\n                    lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n                    // we could check if we have the expected Y value\n                    ascii = values[j].charCodeAt(0);\n\n                    if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n                        // + - . 0 1 2 3 4 5 6 7 8 9\n                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                            expectedY = +values[j];\n                        } else\n                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                        if ((ascii > 63) && (ascii < 74)) {\n                            expectedY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                        } else\n                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                        if ((ascii > 96) && (ascii < 106)) {\n                            expectedY = -(String.fromCharCode(ascii - 48) + values[j].substring(1));\n                        }\n                        if (expectedY !== currentY) {\n                            result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n                            result.logs.push('Previous values: ' + previousValues.length);\n                            result.logs.push(previousValues);\n                        }\n                    }\n                } else {\n                    if (values[j].length > 0) {\n                        ascii = values[j].charCodeAt(0);\n                        // + - . 0 1 2 3 4 5 6 7 8 9\n                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                            lastDif = null;\n                            currentY = +values[j];\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                        if ((ascii > 63) && (ascii < 74)) {\n                            lastDif = null;\n                            currentY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++] = currentX;\n                            currentData[currentPosition++] = currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                        if ((ascii > 96) && (ascii < 106)) {\n                            lastDif = null;\n                            // we can multiply the string by 1 because if may not contain decimal (is this correct ????)\n                            currentY = -(String.fromCharCode(ascii - 48) + values[j].substring(1))*1;\n                            //currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n\n\n\n                        // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                        if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n                            var dup = (String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n                            if (ascii === 115) {\n                                dup = ('9' + values[j].substring(1)) - 1;\n                            }\n                            for (var l = 0; l < dup; l++) {\n                                if (lastDif) {\n                                    currentY = currentY + lastDif;\n                                }\n                                // currentData.push(currentX, currentY * spectrum.yFactor);\n                                currentData[currentPosition++]=currentX;\n                                currentData[currentPosition++]=currentY * spectrum.yFactor;\n                                currentX += spectrum.deltaX;\n                            }\n                        } else\n                        // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                        if (ascii === 37) {\n                            lastDif = +('0' + values[j].substring(1));\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else if ((ascii > 73) && (ascii < 83)) {\n                            lastDif = (String.fromCharCode(ascii - 25) + values[j].substring(1))*1;\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // negative DIF digits j k l m n o p q r (ascii 106-114)\n                        if ((ascii > 105) && (ascii < 115)) {\n                            lastDif = -(String.fromCharCode(ascii - 57) + values[j].substring(1))*1;\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parseXYData.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}