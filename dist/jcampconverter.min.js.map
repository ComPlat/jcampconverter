{"version":3,"sources":["webpack:///jcampconverter/webpack/universalModuleDefinition","webpack:///jcampconverter/jcampconverter.min.js","webpack:///jcampconverter/webpack/bootstrap 5b253e310afd4f176f4c","webpack:///jcampconverter/./src/index.js","webpack:///jcampconverter/./src/parseXYData.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","getConverter","convertToFloatArray","stringArray","l","length","floatArray","Array","i","parseFloat","convert","jcamp","options","keepRecordsRegExp","ldr","dataLabel","dataValue","ldrs","ii","position","endLine","infos","start","Date","now","ntuples","result","profiling","logs","spectra","info","spectrum","push","action","time","split","replace","indexOf","substring","trim","toUpperCase","xIndex","yIndex","firstVariable","secondVariable","symbol","first","firstX","firstY","last","lastX","lastY","vardim","nbPoints","factor","xFactor","yFactor","units","xUnit","yUnit","datatable","deltaX","title","dataType","twoD","observeFrequency","xType","indirectFrequency","shiftOffsetNum","shiftOffsetVal","varname","ntuplesSeparator","vartype","varform","min","max","yType","page","pageValue","pageSymbol","pageSymbolIndex","unit","prepareSpectrum","match","fastParse","parseXYDataRegExp","fastParseXYData","parsePeakTable","isMSField","convertMSFieldToLabel","Object","keys","newNtuples","key","values","j","add2D","keepSpectra","isGCMS","newGCMS","xy","data","newData","x","y","k","addNewGCMS","addGCMS","value","toLowerCase","GC_MS_FIELDS","gcms","times","series","name","dimension","existingGCMSFields","label","gc","ms","shift","convertTo3DZ","noise","minZ","maxZ","ySize","xSize","z","xVector","Math","abs","minX","maxX","minY","maxY","zData","contourLines","generateContourLines","minMax","povarHeight0","povarHeight1","povarHeight2","povarHeight3","isOver0","isOver1","isOver2","isOver3","pAx","pAy","pBx","pBy","lineZValue","contourLevels","nbLevels","nbSubSpectra","nbPovars","x0","xN","dx","y0","yN","dy","level","contourLevel","side","exp","lines","zValue","iSubSpectra","subSpectra","subSpectraAfter","povar","segments","isXYdata","currentData","currentPosition","currentX","currentY","ascii","charCodeAt","newLine","isDifference","isLastDifference","lastDifference","isDuplicate","inComment","currentValue","isNegative","inValue","skipFirstValue","decimalPosition","pow","duplicate","ascii2","removeCommentRegExp","peakTableSplitRegExp","isPeaktable","jj","JcampConverter","input","useWorker","postToWorker","worker","createWorker","Promise","resolve","stamp","random","stamps","postMessage","workerURL","URL","createObjectURL","Blob","toString","type","Worker","revokeObjectURL","addEventListener","event","output","xyDataSplitRegExp","DEBUG","lastDif","firstPoint","expectedCurrentX","String","fromCharCode","dup"],"mappings":"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","file":"jcampconverter.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JcampConverter\"] = factory();\n\telse\n\t\troot[\"JcampConverter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JcampConverter\"] = factory();\n\telse\n\t\troot[\"JcampConverter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar parseXYDataRegExp=__webpack_require__(1);\n\t\n\t\n\tfunction getConverter() {\n\t\n\t    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n\t    var ntuplesSeparator = /[, \\t]{1,}/;\n\t\n\t    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\t\n\t    function convertToFloatArray(stringArray) {\n\t        var l = stringArray.length;\n\t        var floatArray = new Array(l);\n\t        for (var i = 0; i < l; i++) {\n\t            floatArray[i] = parseFloat(stringArray[i]);\n\t        }\n\t        return floatArray;\n\t    }\n\t\n\t    /*\n\t     options.keepSpectra: keep the original spectra for a 2D\n\t     options.xy: true // create x / y array instead of a 1D array\n\t     options.keepRecordsRegExp: which fields do we keep\n\t     */\n\t\n\t    function convert(jcamp, options) {\n\t        options = options || {};\n\t\n\t        var keepRecordsRegExp=/^$/;\n\t        if (options.keepRecordsRegExp) keepRecordsRegExp=options.keepRecordsRegExp;\n\t\n\t        var start = Date.now();\n\t\n\t        var ntuples = {},\n\t            ldr,\n\t            dataLabel,\n\t            dataValue,\n\t            ldrs,\n\t            i, ii, position, endLine, infos;\n\t\n\t        var result = {};\n\t        result.profiling = [];\n\t        result.logs = [];\n\t        var spectra = [];\n\t        result.spectra = spectra;\n\t        result.info = {};\n\t        var spectrum = {};\n\t\n\t        if (!(typeof jcamp === 'string')) return result;\n\t        // console.time('start');\n\t\n\t        if (result.profiling) result.profiling.push({action: 'Before split to LDRS', time: Date.now() - start});\n\t\n\t        ldrs = jcamp.split(/[\\r\\n]+##/);\n\t\n\t        if (result.profiling) result.profiling.push({action: 'Split to LDRS', time: Date.now() - start});\n\t\n\t        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\t\n\t        for (i = 0, ii = ldrs.length; i < ii; i++) {\n\t            ldr = ldrs[i];\n\t            // This is a new LDR\n\t            position = ldr.indexOf('=');\n\t            if (position > 0) {\n\t                dataLabel = ldr.substring(0, position);\n\t                dataValue = ldr.substring(position + 1).trim();\n\t            } else {\n\t                dataLabel = ldr;\n\t                dataValue = '';\n\t            }\n\t            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\t\n\t            if (dataLabel === 'DATATABLE') {\n\t                endLine = dataValue.indexOf('\\n');\n\t                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n\t                if (endLine > 0) {\n\t                    var xIndex = -1;\n\t                    var yIndex = -1;\n\t                    // ##DATA TABLE= (X++(I..I)), XYDATA\n\t                    // We need to find the variables\n\t\n\t                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n\t                    if (infos[0].indexOf('++') > 0) {\n\t                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n\t                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n\t                        xIndex = ntuples.symbol.indexOf(firstVariable);\n\t                        yIndex = ntuples.symbol.indexOf(secondVariable);\n\t                    }\n\t\n\t                    if (xIndex === -1) xIndex = 0;\n\t                    if (yIndex === -1) yIndex = 0;\n\t\n\t                    if (ntuples.first) {\n\t                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n\t                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n\t                    }\n\t                    if (ntuples.last) {\n\t                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n\t                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n\t                    }\n\t                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n\t                        spectrum.nbPoints = ntuples.vardim[xIndex];\n\t                    }\n\t                    if (ntuples.factor) {\n\t                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n\t                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n\t                    }\n\t                    if (ntuples.units) {\n\t                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n\t                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n\t                    }\n\t                    spectrum.datatable = infos[0];\n\t                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n\t                        dataLabel = 'PEAKTABLE';\n\t                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n\t                        dataLabel = 'XYDATA';\n\t                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t                    }\n\t                }\n\t            }\n\t\n\t\n\t            if (dataLabel === 'TITLE') {\n\t                spectrum.title = dataValue;\n\t            } else if (dataLabel === 'DATATYPE') {\n\t                spectrum.dataType = dataValue;\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'NTUPLES') {\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'XUNITS') {\n\t                spectrum.xUnit = dataValue;\n\t            } else if (dataLabel === 'YUNITS') {\n\t                spectrum.yUnit = dataValue;\n\t            } else if (dataLabel === 'FIRSTX') {\n\t                spectrum.firstX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTX') {\n\t                spectrum.lastX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'FIRSTY') {\n\t                spectrum.firstY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTY') {\n\t                spectrum.lastY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'NPOINTS') {\n\t                spectrum.nbPoints = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XFACTOR') {\n\t                spectrum.xFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'YFACTOR') {\n\t                spectrum.yFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'DELTAX') {\n\t                spectrum.deltaX = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n\t                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVENUCLEUS') {\n\t                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n\t            } else if (dataLabel === '$SFO2') {\n\t                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\t\n\t            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n\t                result.shiftOffsetNum = 0;\n\t                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n\t            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\t\n\t\n\t                // if we activate this part it does not work for ACD specmanager\n\t                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n\t                //                 var parts = dataValue.split(/ *, */);\n\t                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n\t                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n\t            } else if (dataLabel === 'VARNAME') {\n\t                ntuples.varname = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'SYMBOL') {\n\t                ntuples.symbol = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARTYPE') {\n\t                ntuples.vartype = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARFORM') {\n\t                ntuples.varform = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'VARDIM') {\n\t                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'UNITS') {\n\t                ntuples.units = dataValue.split(ntuplesSeparator);\n\t            } else if (dataLabel === 'FACTOR') {\n\t                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'FIRST') {\n\t                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'LAST') {\n\t                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'MIN') {\n\t                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === 'MAX') {\n\t                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n\t            } else if (dataLabel === '.NUCLEUS') {\n\t                if (result.twoD) {\n\t                    result.yType = dataValue.split(ntuplesSeparator)[0];\n\t                }\n\t            } else if (dataLabel === 'PAGE') {\n\t                spectrum.page = dataValue.trim();\n\t                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n\t                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n\t                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n\t                var unit = '';\n\t                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n\t                    unit = ntuples.units[pageSymbolIndex];\n\t                }\n\t                if (result.indirectFrequency && unit !== 'PPM') {\n\t                    spectrum.pageValue /= result.indirectFrequency;\n\t                }\n\t            } else if (dataLabel === 'RETENTIONTIME') {\n\t                spectrum.pageValue = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XYDATA') {\n\t                prepareSpectrum(result, spectrum);\n\t                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n\t                if (dataValue.match(/.*\\+\\+.*/)) {\n\t                    if (options.fastParse===false) {\n\t                        parseXYDataRegExp(spectrum, dataValue, result);\n\t                    } else {\n\t                        if (!spectrum.deltaX) {\n\t                            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t                        }\n\t                        fastParseXYData(spectrum, dataValue, result);\n\t                    }\n\t                } else {\n\t                    parsePeakTable(spectrum, dataValue, result);\n\t                }\n\t                spectra.push(spectrum);\n\t                spectrum = {};\n\t            } else if (dataLabel === 'PEAKTABLE') {\n\t                prepareSpectrum(result, spectrum);\n\t                parsePeakTable(spectrum, dataValue, result);\n\t                spectra.push(spectrum);\n\t                spectrum = {};\n\t            } else if (isMSField(dataLabel)) {\n\t                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n\t            }\n\t            if (dataLabel.match(keepRecordsRegExp)) {\n\t                result.info[dataLabel] = dataValue.trim();\n\t            }\n\t        }\n\t\n\t        // Currently disabled\n\t        //    if (options && options.lowRes) addLowRes(spectra,options);\n\t\n\t        if (result.profiling) result.profiling.push({action: 'Finished parsing', time: Date.now() - start});\n\t\n\t        if (Object.keys(ntuples).length>0) {\n\t            var newNtuples=[];\n\t            var keys=Object.keys(ntuples);\n\t            for (var i=0; i<keys.length; i++) {\n\t                var key=keys[i];\n\t                var values=ntuples[key];\n\t                for (var j=0; j<values.length; j++) {\n\t                    if (! newNtuples[j]) newNtuples[j]={};\n\t                    newNtuples[j][key]=values[j];\n\t                }\n\t            }\n\t            result.ntuples=newNtuples;\n\t        }\n\t\n\t        if (result.twoD) {\n\t            add2D(result);\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished countour plot calculation',\n\t                time: Date.now() - start\n\t            });\n\t            if (!options.keepSpectra) {\n\t                delete result.spectra;\n\t            }\n\t        }\n\t\n\t        var isGCMS = (spectra.length > 1 && (! spectra[0].dataType || spectra[0].dataType.match(/.*mass.*/i)));\n\t        if (isGCMS && options.newGCMS) {\n\t            options.xy = true;\n\t        }\n\t\n\t        if (options.xy) { // the spectraData should not be a oneD array but an object with x and y\n\t            if (spectra.length > 0) {\n\t                for (var i=0; i<spectra.length; i++) {\n\t                    var spectrum=spectra[i];\n\t                    if (spectrum.data.length>0) {\n\t                        for (var j=0; j<spectrum.data.length; j++) {\n\t                            var data=spectrum.data[j];\n\t                            var newData={x: new Array(data.length/2), y:new Array(data.length/2)};\n\t                            for (var k=0; k<data.length; k=k+2) {\n\t                                newData.x[k/2]=data[k];\n\t                                newData.y[k/2]=data[k+1];\n\t                            }\n\t                            spectrum.data[j]=newData;\n\t                        }\n\t\n\t                    }\n\t\n\t                }\n\t            }\n\t        }\n\t\n\t        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n\t        if (isGCMS) {\n\t            if (options.newGCMS) {\n\t                addNewGCMS(result);\n\t            } else {\n\t                addGCMS(result);\n\t            }\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished GCMS calculation',\n\t                time: Date.now() - start\n\t            });\n\t        }\n\t\n\t        if (result.profiling) {\n\t            result.profiling.push({action: 'Total time', time: Date.now() - start});\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t\n\t    function convertMSFieldToLabel(value) {\n\t        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n\t    }\n\t\n\t    function isMSField(dataLabel) {\n\t        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n\t    }\n\t\n\t    function addNewGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var length  = spectra.length;\n\t        var gcms = {\n\t            times: new Array(length),\n\t            series: [{\n\t                name: 'ms',\n\t                dimension: 2,\n\t                data: new Array(length)\n\t            }]\n\t        };\n\t\n\t        var i;\n\t        var existingGCMSFields = [];\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t                gcms.series.push({\n\t                    name: label,\n\t                    dimension: 1,\n\t                    data: new Array(length)\n\t                });\n\t            }\n\t        }\n\t\n\t        for (i = 0; i < length; i++) {\n\t            var spectrum = spectra[i];\n\t            gcms.times[i] = spectrum.pageValue;\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.series[j + 1].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n\t            }\n\t            if (spectrum.data) {\n\t                gcms.series[0].data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n\t            }\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function addGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var existingGCMSFields = [];\n\t        var i;\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t            }\n\t        }\n\t        if (existingGCMSFields.length===0) return;\n\t        var gcms = {};\n\t        gcms.gc = {};\n\t        gcms.ms = [];\n\t        for (i = 0; i < existingGCMSFields.length; i++) {\n\t            gcms.gc[existingGCMSFields[i]] = [];\n\t        }\n\t        for (i = 0; i < spectra.length; i++) {\n\t            var spectrum = spectra[i];\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n\t                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n\t            }\n\t          if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function prepareSpectrum(result, spectrum) {\n\t        if (!spectrum.xFactor) spectrum.xFactor = 1;\n\t        if (!spectrum.yFactor) spectrum.yFactor = 1;\n\t        if (spectrum.observeFrequency) {\n\t            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n\t                spectrum.xUnit = 'PPM';\n\t                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n\t                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n\t                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n\t                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n\t            }\n\t        }\n\t        if (result.shiftOffsetVal) {\n\t            var shift = spectrum.firstX - result.shiftOffsetVal;\n\t            spectrum.firstX = spectrum.firstX - shift;\n\t            spectrum.lastX = spectrum.lastX - shift;\n\t        }\n\t    }\n\t\n\t\n\t\n\t    function convertTo3DZ(spectra) {\n\t        var noise = 0;\n\t        var minZ = spectra[0].data[0][0];\n\t        var maxZ = minZ;\n\t        var ySize = spectra.length;\n\t        var xSize = spectra[0].data[0].length / 2;\n\t        var z = new Array(ySize);\n\t        for (var i = 0; i < ySize; i++) {\n\t            z[i] = new Array(xSize);\n\t            var xVector=spectra[i].data[0];\n\t            for (var j = 0; j < xSize; j++) {\n\t                var value = xVector[j * 2 + 1];\n\t                z[i][j] = value;\n\t                if (value < minZ) minZ = value;\n\t                if (value > maxZ) maxZ = value;\n\t                if (i !== 0 && j !== 0) {\n\t                    noise += Math.abs(value - z[i][j - 1]) + Math.abs(value - z[i - 1][j]);\n\t                }\n\t            }\n\t        }\n\t        return {\n\t            z: z,\n\t            minX: spectra[0].data[0][0],\n\t            maxX: spectra[0].data[0][spectra[0].data[0].length - 2], // has to be -2 because it is a 1D array [x,y,x,y,...]\n\t            minY: spectra[0].pageValue,\n\t            maxY: spectra[ySize - 1].pageValue,\n\t            minZ: minZ,\n\t            maxZ: maxZ,\n\t            noise: noise / ((ySize - 1) * (xSize - 1) * 2)\n\t        };\n\t\n\t    }\n\t\n\t    function add2D(result) {\n\t        var zData = convertTo3DZ(result.spectra);\n\t        result.contourLines = generateContourLines(zData);\n\t        delete zData.z;\n\t        result.minMax = zData;\n\t    }\n\t\n\t\n\t    function generateContourLines(zData, options) {\n\t        // console.time('generateContourLines');\n\t        var noise = zData.noise;\n\t        var z = zData.z;\n\t        var contourLevels = [];\n\t        var nbLevels = 7;\n\t        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n\t        var isOver0, isOver1, isOver2, isOver3;\n\t        var nbSubSpectra = z.length;\n\t        var nbPovars = z[0].length;\n\t        var pAx, pAy, pBx, pBy;\n\t\n\t        var x0 = zData.minX;\n\t        var xN = zData.maxX;\n\t        var dx = (xN - x0) / (nbPovars - 1);\n\t        var y0 = zData.minY;\n\t        var yN = zData.maxY;\n\t        var dy = (yN - y0) / (nbSubSpectra - 1);\n\t        var minZ = zData.minZ;\n\t        var maxZ = zData.maxZ;\n\t\n\t        //System.out.prvarln('y0 '+y0+' yN '+yN);\n\t        // -------------------------\n\t        // Povars attribution\n\t        //\n\t        // 0----1\n\t        // |  / |\n\t        // | /  |\n\t        // 2----3\n\t        //\n\t        // ---------------------d------\n\t\n\t        var lineZValue;\n\t        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n\t            var contourLevel = {};\n\t            contourLevels[level]=contourLevel;\n\t            var side = level % 2;\n\t            if (side === 0) {\n\t                lineZValue = (maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) + 5 * noise;\n\t            } else {\n\t                lineZValue = -(maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) - 5 * noise;\n\t            }\n\t            var lines = [];\n\t            contourLevel.zValue = lineZValue;\n\t            contourLevel.lines = lines;\n\t\n\t            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\t\n\t            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n\t                var subSpectra = z[iSubSpectra];\n\t                var subSpectraAfter = z[iSubSpectra + 1];\n\t                for (var povar = 0; povar < nbPovars - 1; povar++) {\n\t                    povarHeight0 = subSpectra[povar];\n\t                    povarHeight1 = subSpectra[povar + 1];\n\t                    povarHeight2 = subSpectraAfter[povar];\n\t                    povarHeight3 = subSpectraAfter[povar + 1];\n\t                    \n\t                    isOver0 = (povarHeight0 > lineZValue);\n\t                    isOver1 = (povarHeight1 > lineZValue);\n\t                    isOver2 = (povarHeight2 > lineZValue);\n\t                    isOver3 = (povarHeight3 > lineZValue);\n\t                    \n\t                    // Example povar0 is over the plane and povar1 and\n\t                    // povar2 are below, we find the varersections and add\n\t                    // the segment\n\t                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n\t                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n\t                        pAy = iSubSpectra;\n\t                        pBx = povar;\n\t                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n\t                        lines.push(pAx * dx + x0); lines.push(pAy * dy + y0); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                    }\n\t                    // remove push does not help !!!!\n\t                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n\t                        pAx = povar + 1;\n\t                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n\t                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n\t                        pBy = iSubSpectra + 1;\n\t                        lines.push(pAx * dx + x0); lines.push(pAy * dy + y0); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                    }\n\t                    // test around the diagonal\n\t                    if (isOver1 !== isOver2) {\n\t                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n\t                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n\t                        if (isOver1 !== isOver0) {\n\t                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n\t                            pBy = iSubSpectra;\n\t                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver2 !== isOver0) {\n\t                            pBx = povar;\n\t                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n\t                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver1 !== isOver3) {\n\t                            pBx = povar + 1;\n\t                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n\t                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                        }\n\t                        if (isOver2 !== isOver3) {\n\t                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n\t                            pBy = iSubSpectra + 1;\n\t                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        // console.timeEnd('generateContourLines');\n\t        return {\n\t            minX: zData.minX,\n\t            maxX: zData.maxX,\n\t            minY: zData.minY,\n\t            maxY: zData.maxY,\n\t            segments: contourLevels\n\t        };\n\t        //return contourLevels;\n\t    }\n\t\n\t\n\t    function addLowRes(spectra, options) {\n\t        var spectrum;\n\t        var averageX, averageY;\n\t        var targetNbPoints = options.lowRes;\n\t        var highResData;\n\t        for (var i = 0; i < spectra.length; i++) {\n\t            spectrum = spectra[i];\n\t            // we need to find the current higher resolution\n\t            if (spectrum.data.length > 0) {\n\t                highResData = spectrum.data[0];\n\t                for (var j = 1; j < spectrum.data.length; j++) {\n\t                    if (spectrum.data[j].length > highResData.length) {\n\t                        highResData = spectrum.data[j];\n\t                    }\n\t                }\n\t\n\t                if (targetNbPoints > (highResData.length / 2)) return;\n\t                var i, ii;\n\t                var lowResData = [];\n\t                var modulo = Math.ceil(highResData.length / (targetNbPoints * 2));\n\t                for (i = 0, ii = highResData.length; i < ii; i = i + 2) {\n\t                    if (i % modulo === 0) {\n\t                        lowResData.push(highResData[i], highResData[i + 1])\n\t                    }\n\t                }\n\t                spectrum.data.push(lowResData);\n\t            }\n\t        }\n\t    }\n\t\n\t    function fastParseXYData(spectrum, value) {\n\t        // TODO need to deal with result\n\t        //  console.log(value);\n\t        // we check if deltaX is defined otherwise we calculate it\n\t\n\t        var yFactor = spectrum.yFactor;\n\t        var deltaX = spectrum.deltaX;\n\t        \n\t\n\t        spectrum.isXYdata = true;\n\t        // TODO to be improved using 2 array {x:[], y:[]}\n\t        var currentData = [];\n\t        var currentPosition = 0;\n\t        spectrum.data = [currentData];\n\t\n\t\n\t        var currentX = spectrum.firstX;\n\t        var currentY = spectrum.firstY;\n\t\n\t        // we skip the first line\n\t        //\n\t        var endLine = false;\n\t        for (var i = 0; i < value.length; i++) {\n\t            var ascii = value.charCodeAt(i);\n\t            if (ascii === 13 || ascii === 10) {\n\t                endLine = true;\n\t            } else {\n\t                if (endLine) break;\n\t            }\n\t        }\n\t\n\t        // we proceed taking the i after the first line\n\t        var newLine = true;\n\t        var isDifference=false;\n\t        var isLastDifference=false;\n\t        var lastDifference=0;\n\t        var isDuplicate=false;\n\t        var inComment = false;\n\t        var currentValue = 0;\n\t        var isNegative = false;\n\t        var inValue=false;\n\t        var skipFirstValue=false;\n\t        var decimalPosition = 0;\n\t        var ascii;\n\t        for (; i <= value.length; i++) {\n\t            if (i===value.length) ascii=13;\n\t            else ascii = value.charCodeAt(i);\n\t            if (inComment) {\n\t                // we should ignore the text if we are after $$\n\t                if (ascii === 13 || ascii === 10) {\n\t                    newLine = true;\n\t                    inComment = false;\n\t                }\n\t            } else {\n\t                // when is it a new value ?\n\t                // when it is not a digit, . or comma\n\t                // it is a number that is either new or we continue\n\t                if ( ascii <= 57 && ascii >= 48) { // a number\n\t                    inValue=true;\n\t                    if (decimalPosition > 0) {\n\t                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n\t                    } else {\n\t                        currentValue *= 10;\n\t                        currentValue += ascii - 48;\n\t                    }\n\t                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n\t                    inValue=true;\n\t                    decimalPosition++;\n\t                } else {\n\t                    if (inValue) {\n\t                        // need to process the previous value\n\t                        if (newLine) {\n\t                            newLine = false; // we don't check the X value\n\t                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n\t                            // if new line and lastDifference, the first value is just a check !\n\t                            // that we don't check ...\n\t                            if (isLastDifference) skipFirstValue=true;\n\t                        } else {\n\t                            // need to deal with duplicate and differences\n\t                            if (skipFirstValue) {\n\t                                skipFirstValue=false;\n\t                            } else {\n\t                                if (isDifference) {\n\t                                    if (currentValue===0) lastDifference=0;\n\t                                    else lastDifference=isNegative ? -currentValue : currentValue;\n\t                                    isLastDifference=true;\n\t                                    isDifference=false;\n\t                                }\n\t                                var duplicate=isDuplicate ? currentValue - 1 : 1;\n\t                                for (var j=0; j<duplicate; j++) {\n\t                                    if (isLastDifference) {\n\t                                        currentY += lastDifference;\n\t                                    } else {\n\t                                        if (currentValue===0) currentY=0;\n\t                                        else currentY = isNegative ? -currentValue : currentValue;\n\t                                    }\n\t\n\t                                    //  console.log(\"Separator\",isNegative ?\n\t                                    //          -currentValue : currentValue,\n\t                                    //      \"isDiff\", isDifference, \"isDup\", isDuplicate,\n\t                                    //      \"lastDif\", lastDifference, \"dup:\", duplicate, \"y\", currentY);\n\t\n\t                                    // push is slightly slower ... (we loose 10%)\n\t                                    currentData[currentPosition++]=currentX;\n\t                                    currentData[currentPosition++]=currentY * yFactor;\n\t                                    currentX += deltaX;\n\t                                }\n\t                            }\n\t                        }\n\t                        isNegative=false;\n\t                        currentValue=0;\n\t                        decimalPosition=0;\n\t                        inValue=false;\n\t                        isDuplicate=false;\n\t                    }\n\t\n\t                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                    if ((ascii < 74) && (ascii > 63)) {\n\t                        inValue=true;\n\t                        isLastDifference=false;\n\t                        currentValue=ascii-64;\n\t                    } else\n\t                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                    if ((ascii > 96) && (ascii < 106)) {\n\t                        inValue=true;\n\t                        isLastDifference=false;\n\t                        currentValue=ascii-96;\n\t                        isNegative=true;\n\t                    } else\n\t                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                    if (ascii===115) {\n\t                        inValue=true;\n\t                        isDuplicate=true;\n\t                        currentValue=9;\n\t                    } else if ((ascii > 82) && (ascii < 91)) {\n\t                        inValue=true;\n\t                        isDuplicate=true;\n\t                        currentValue=ascii-82;\n\t                    } else\n\t                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                    if ((ascii > 73) && (ascii < 83)) {\n\t                        inValue=true;\n\t                        isDifference=true;\n\t                        currentValue=ascii-73;\n\t                    } else\n\t                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                    if ((ascii > 105) && (ascii < 115)) {\n\t                        inValue=true;\n\t                        isDifference=true;\n\t                        currentValue=ascii-105;\n\t                        isNegative=true;\n\t                    } else\n\t                    // $ sign, we need to check the next one\n\t                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n\t                        inValue=true;\n\t                        inComment = true;\n\t                    } else\n\t                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                    if (ascii === 37) {\n\t                        inValue=true;\n\t                        isDifference=true;\n\t                        currentValue=0;\n\t                        isNegative=false;\n\t                    } else\n\t                    if (ascii === 45) { // a \"-\"\n\t                        // check if after there is a number, decimal or comma\n\t                        var ascii2=value.charCodeAt(i+1);\n\t                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n\t                            inValue=true;\n\t                            isLastDifference=false;\n\t                            isNegative = true;\n\t                        }\n\t                    } else if (ascii === 13 || ascii === 10) {\n\t                        newLine = true;\n\t                        inComment = false;\n\t                    }\n\t                    // and now analyse the details ... space or tabulation\n\t                    // if \"+\" we just don't care\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function parsePeakTable(spectrum, value, result) {\n\t        var removeCommentRegExp = /\\$\\$.*/;\n\t        var peakTableSplitRegExp = /[,\\t ]+/;\n\t        \n\t        spectrum.isPeaktable=true;\n\t        var i, ii, j, jj, values;\n\t        var currentData = [];\n\t        spectrum.data = [currentData];\n\t\n\t        // counts for around 20% of the time\n\t        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\t\n\t        var k = 0;\n\t        for (i = 1, ii = lines.length; i < ii; i++) {\n\t            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n\t            if (values.length % 2 === 0) {\n\t                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n\t                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n\t                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n\t                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n\t                }\n\t            } else {\n\t                result.logs.push('Format error: ' + values);\n\t            }\n\t        }\n\t    }\n\t\n\t\n\t\n\t    return convert;\n\t\n\t}\n\t\n\tvar convert = getConverter();\n\t\n\tfunction JcampConverter(input, options, useWorker) {\n\t    if (typeof options === 'boolean') {\n\t        useWorker = options;\n\t        options = {};\n\t    }\n\t    if (useWorker) {\n\t        return postToWorker(input, options);\n\t    } else {\n\t        return convert(input, options);\n\t    }\n\t}\n\t\n\tvar stamps = {},\n\t    worker;\n\t\n\tfunction postToWorker(input, options) {\n\t    if (!worker) {\n\t        createWorker();\n\t    }\n\t    return new Promise(function (resolve) {\n\t        var stamp = Date.now() + '' + Math.random();\n\t        stamps[stamp] = resolve;\n\t        worker.postMessage({stamp: stamp, input: input, options: options});\n\t    });\n\t}\n\t\n\tfunction createWorker() {\n\t    var workerURL = URL.createObjectURL(new Blob([\n\t        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { postMessage({stamp: event.data.stamp, output: convert(event.data.input, event.data.options)}); };'\n\t    ], {type: 'application/javascript'}));\n\t    worker = new Worker(workerURL);\n\t    URL.revokeObjectURL(workerURL);\n\t    worker.addEventListener('message', function (event) {\n\t        var stamp = event.data.stamp;\n\t        if (stamps[stamp]) {\n\t            stamps[stamp](event.data.output);\n\t        }\n\t    });\n\t}\n\t\n\tmodule.exports = {\n\t    convert: JcampConverter\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\tvar xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\n\tvar removeCommentRegExp = /\\$\\$.*/;\n\tvar DEBUG=false;\n\t\n\tmodule.exports=function(spectrum, value, result) {\n\t    // we check if deltaX is defined otherwise we calculate it\n\t    if (!spectrum.deltaX) {\n\t        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t    }\n\t\n\t    spectrum.isXYdata=true;\n\t\n\t    var currentData = [];\n\t    var currentPosition=0;\n\t    spectrum.data = [currentData];\n\t\n\t    var currentX = spectrum.firstX;\n\t    var currentY = spectrum.firstY;\n\t    var lines = value.split(/[\\r\\n]+/);\n\t    var lastDif, values, ascii, expectedY;\n\t    values = [];\n\t    for (var i = 1, ii = lines.length; i < ii; i++) {\n\t        //var previousValues=JSON.parse(JSON.stringify(values));\n\t        values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n\t        if (values.length > 0) {\n\t            if (DEBUG) {\n\t                if (!spectrum.firstPoint) {\n\t                    spectrum.firstPoint = +values[0];\n\t                }\n\t                var expectedCurrentX = (values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n\t                if ((lastDif || lastDif === 0)) {\n\t                    expectedCurrentX += spectrum.deltaX;\n\t                }\n\t                result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n\t            }\n\t            for (var j = 1, jj = values.length; j < jj; j++) {\n\t                if (j === 1 && (lastDif || lastDif === 0)) {\n\t                    lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n\t                    // we could check if we have the expected Y value\n\t                    ascii = values[j].charCodeAt(0);\n\t\n\t                    if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n\t                        // + - . 0 1 2 3 4 5 6 7 8 9\n\t                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                            expectedY = +values[j];\n\t                        } else\n\t                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                        if ((ascii > 63) && (ascii < 74)) {\n\t                            expectedY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                        } else\n\t                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                        if ((ascii > 96) && (ascii < 106)) {\n\t                            expectedY = -(String.fromCharCode(ascii - 48) + values[j].substring(1));\n\t                        }\n\t                        if (expectedY !== currentY) {\n\t                            result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n\t                            result.logs.push('Previous values: ' + previousValues.length);\n\t                            result.logs.push(previousValues);\n\t                        }\n\t                    }\n\t                } else {\n\t                    if (values[j].length > 0) {\n\t                        ascii = values[j].charCodeAt(0);\n\t                        // + - . 0 1 2 3 4 5 6 7 8 9\n\t                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                            lastDif = null;\n\t                            currentY = +values[j];\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                        if ((ascii > 63) && (ascii < 74)) {\n\t                            lastDif = null;\n\t                            currentY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++] = currentX;\n\t                            currentData[currentPosition++] = currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                        if ((ascii > 96) && (ascii < 106)) {\n\t                            lastDif = null;\n\t                            // we can multiply the string by 1 because if may not contain decimal (is this correct ????)\n\t                            currentY = -(String.fromCharCode(ascii - 48) + values[j].substring(1))*1;\n\t                            //currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t\n\t\n\t\n\t                        // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                        if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n\t                            var dup = (String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n\t                            if (ascii === 115) {\n\t                                dup = ('9' + values[j].substring(1)) - 1;\n\t                            }\n\t                            for (var l = 0; l < dup; l++) {\n\t                                if (lastDif) {\n\t                                    currentY = currentY + lastDif;\n\t                                }\n\t                                // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                                currentData[currentPosition++]=currentX;\n\t                                currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                                currentX += spectrum.deltaX;\n\t                            }\n\t                        } else\n\t                        // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                        if (ascii === 37) {\n\t                            lastDif = +('0' + values[j].substring(1));\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else if ((ascii > 73) && (ascii < 83)) {\n\t                            lastDif = (String.fromCharCode(ascii - 25) + values[j].substring(1))*1;\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        } else\n\t                        // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                        if ((ascii > 105) && (ascii < 115)) {\n\t                            lastDif = -(String.fromCharCode(ascii - 57) + values[j].substring(1))*1;\n\t                            currentY += lastDif;\n\t                            // currentData.push(currentX, currentY * spectrum.yFactor);\n\t                            currentData[currentPosition++]=currentX;\n\t                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n\t                            currentX += spectrum.deltaX;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** jcampconverter.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5b253e310afd4f176f4c\n **/","'use strict';\n\nvar parseXYDataRegExp=require('./parseXYData.js');\n\n\nfunction getConverter() {\n\n    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n    var ntuplesSeparator = /[, \\t]{1,}/;\n\n    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\n    function convertToFloatArray(stringArray) {\n        var l = stringArray.length;\n        var floatArray = new Array(l);\n        for (var i = 0; i < l; i++) {\n            floatArray[i] = parseFloat(stringArray[i]);\n        }\n        return floatArray;\n    }\n\n    /*\n     options.keepSpectra: keep the original spectra for a 2D\n     options.xy: true // create x / y array instead of a 1D array\n     options.keepRecordsRegExp: which fields do we keep\n     */\n\n    function convert(jcamp, options) {\n        options = options || {};\n\n        var keepRecordsRegExp=/^$/;\n        if (options.keepRecordsRegExp) keepRecordsRegExp=options.keepRecordsRegExp;\n\n        var start = Date.now();\n\n        var ntuples = {},\n            ldr,\n            dataLabel,\n            dataValue,\n            ldrs,\n            i, ii, position, endLine, infos;\n\n        var result = {};\n        result.profiling = [];\n        result.logs = [];\n        var spectra = [];\n        result.spectra = spectra;\n        result.info = {};\n        var spectrum = {};\n\n        if (!(typeof jcamp === 'string')) return result;\n        // console.time('start');\n\n        if (result.profiling) result.profiling.push({action: 'Before split to LDRS', time: Date.now() - start});\n\n        ldrs = jcamp.split(/[\\r\\n]+##/);\n\n        if (result.profiling) result.profiling.push({action: 'Split to LDRS', time: Date.now() - start});\n\n        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n        for (i = 0, ii = ldrs.length; i < ii; i++) {\n            ldr = ldrs[i];\n            // This is a new LDR\n            position = ldr.indexOf('=');\n            if (position > 0) {\n                dataLabel = ldr.substring(0, position);\n                dataValue = ldr.substring(position + 1).trim();\n            } else {\n                dataLabel = ldr;\n                dataValue = '';\n            }\n            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n            if (dataLabel === 'DATATABLE') {\n                endLine = dataValue.indexOf('\\n');\n                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n                if (endLine > 0) {\n                    var xIndex = -1;\n                    var yIndex = -1;\n                    // ##DATA TABLE= (X++(I..I)), XYDATA\n                    // We need to find the variables\n\n                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n                    if (infos[0].indexOf('++') > 0) {\n                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n                        xIndex = ntuples.symbol.indexOf(firstVariable);\n                        yIndex = ntuples.symbol.indexOf(secondVariable);\n                    }\n\n                    if (xIndex === -1) xIndex = 0;\n                    if (yIndex === -1) yIndex = 0;\n\n                    if (ntuples.first) {\n                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n                    }\n                    if (ntuples.last) {\n                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n                    }\n                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n                        spectrum.nbPoints = ntuples.vardim[xIndex];\n                    }\n                    if (ntuples.factor) {\n                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n                    }\n                    if (ntuples.units) {\n                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n                    }\n                    spectrum.datatable = infos[0];\n                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n                        dataLabel = 'PEAKTABLE';\n                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n                        dataLabel = 'XYDATA';\n                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                    }\n                }\n            }\n\n\n            if (dataLabel === 'TITLE') {\n                spectrum.title = dataValue;\n            } else if (dataLabel === 'DATATYPE') {\n                spectrum.dataType = dataValue;\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'NTUPLES') {\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'XUNITS') {\n                spectrum.xUnit = dataValue;\n            } else if (dataLabel === 'YUNITS') {\n                spectrum.yUnit = dataValue;\n            } else if (dataLabel === 'FIRSTX') {\n                spectrum.firstX = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTX') {\n                spectrum.lastX = parseFloat(dataValue);\n            } else if (dataLabel === 'FIRSTY') {\n                spectrum.firstY = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTY') {\n                spectrum.lastY = parseFloat(dataValue);\n            } else if (dataLabel === 'NPOINTS') {\n                spectrum.nbPoints = parseFloat(dataValue);\n            } else if (dataLabel === 'XFACTOR') {\n                spectrum.xFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'YFACTOR') {\n                spectrum.yFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'DELTAX') {\n                spectrum.deltaX = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVENUCLEUS') {\n                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n            } else if (dataLabel === '$SFO2') {\n                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\n            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n                result.shiftOffsetNum = 0;\n                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\n\n                // if we activate this part it does not work for ACD specmanager\n                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n                //                 var parts = dataValue.split(/ *, */);\n                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n            } else if (dataLabel === 'VARNAME') {\n                ntuples.varname = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'SYMBOL') {\n                ntuples.symbol = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARTYPE') {\n                ntuples.vartype = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARFORM') {\n                ntuples.varform = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'VARDIM') {\n                ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'UNITS') {\n                ntuples.units = dataValue.split(ntuplesSeparator);\n            } else if (dataLabel === 'FACTOR') {\n                ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'FIRST') {\n                ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'LAST') {\n                ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MIN') {\n                ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === 'MAX') {\n                ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n            } else if (dataLabel === '.NUCLEUS') {\n                if (result.twoD) {\n                    result.yType = dataValue.split(ntuplesSeparator)[0];\n                }\n            } else if (dataLabel === 'PAGE') {\n                spectrum.page = dataValue.trim();\n                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n                var unit = '';\n                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n                    unit = ntuples.units[pageSymbolIndex];\n                }\n                if (result.indirectFrequency && unit !== 'PPM') {\n                    spectrum.pageValue /= result.indirectFrequency;\n                }\n            } else if (dataLabel === 'RETENTIONTIME') {\n                spectrum.pageValue = parseFloat(dataValue);\n            } else if (dataLabel === 'XYDATA') {\n                prepareSpectrum(result, spectrum);\n                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n                if (dataValue.match(/.*\\+\\+.*/)) {\n                    if (options.fastParse===false) {\n                        parseXYDataRegExp(spectrum, dataValue, result);\n                    } else {\n                        if (!spectrum.deltaX) {\n                            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                        }\n                        fastParseXYData(spectrum, dataValue, result);\n                    }\n                } else {\n                    parsePeakTable(spectrum, dataValue, result);\n                }\n                spectra.push(spectrum);\n                spectrum = {};\n            } else if (dataLabel === 'PEAKTABLE') {\n                prepareSpectrum(result, spectrum);\n                parsePeakTable(spectrum, dataValue, result);\n                spectra.push(spectrum);\n                spectrum = {};\n            } else if (isMSField(dataLabel)) {\n                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n            }\n            if (dataLabel.match(keepRecordsRegExp)) {\n                result.info[dataLabel] = dataValue.trim();\n            }\n        }\n\n        // Currently disabled\n        //    if (options && options.lowRes) addLowRes(spectra,options);\n\n        if (result.profiling) result.profiling.push({action: 'Finished parsing', time: Date.now() - start});\n\n        if (Object.keys(ntuples).length>0) {\n            var newNtuples=[];\n            var keys=Object.keys(ntuples);\n            for (var i=0; i<keys.length; i++) {\n                var key=keys[i];\n                var values=ntuples[key];\n                for (var j=0; j<values.length; j++) {\n                    if (! newNtuples[j]) newNtuples[j]={};\n                    newNtuples[j][key]=values[j];\n                }\n            }\n            result.ntuples=newNtuples;\n        }\n\n        if (result.twoD) {\n            add2D(result);\n            if (result.profiling) result.profiling.push({\n                action: 'Finished countour plot calculation',\n                time: Date.now() - start\n            });\n            if (!options.keepSpectra) {\n                delete result.spectra;\n            }\n        }\n\n        var isGCMS = (spectra.length > 1 && (! spectra[0].dataType || spectra[0].dataType.match(/.*mass.*/i)));\n        if (isGCMS && options.newGCMS) {\n            options.xy = true;\n        }\n\n        if (options.xy) { // the spectraData should not be a oneD array but an object with x and y\n            if (spectra.length > 0) {\n                for (var i=0; i<spectra.length; i++) {\n                    var spectrum=spectra[i];\n                    if (spectrum.data.length>0) {\n                        for (var j=0; j<spectrum.data.length; j++) {\n                            var data=spectrum.data[j];\n                            var newData={x: new Array(data.length/2), y:new Array(data.length/2)};\n                            for (var k=0; k<data.length; k=k+2) {\n                                newData.x[k/2]=data[k];\n                                newData.y[k/2]=data[k+1];\n                            }\n                            spectrum.data[j]=newData;\n                        }\n\n                    }\n\n                }\n            }\n        }\n\n        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n        if (isGCMS) {\n            if (options.newGCMS) {\n                addNewGCMS(result);\n            } else {\n                addGCMS(result);\n            }\n            if (result.profiling) result.profiling.push({\n                action: 'Finished GCMS calculation',\n                time: Date.now() - start\n            });\n        }\n\n        if (result.profiling) {\n            result.profiling.push({action: 'Total time', time: Date.now() - start});\n        }\n\n        return result;\n    }\n\n\n    function convertMSFieldToLabel(value) {\n        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n    }\n\n    function isMSField(dataLabel) {\n        return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n    }\n\n    function addNewGCMS(result) {\n        var spectra = result.spectra;\n        var length  = spectra.length;\n        var gcms = {\n            times: new Array(length),\n            series: [{\n                name: 'ms',\n                dimension: 2,\n                data: new Array(length)\n            }]\n        };\n\n        var i;\n        var existingGCMSFields = [];\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n                gcms.series.push({\n                    name: label,\n                    dimension: 1,\n                    data: new Array(length)\n                });\n            }\n        }\n\n        for (i = 0; i < length; i++) {\n            var spectrum = spectra[i];\n            gcms.times[i] = spectrum.pageValue;\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.series[j + 1].data[i] = parseFloat(spectrum[existingGCMSFields[j]]);\n            }\n            if (spectrum.data) {\n                gcms.series[0].data[i] = [spectrum.data[0].x, spectrum.data[0].y];\n            }\n\n        }\n        result.gcms = gcms;\n    }\n\n    function addGCMS(result) {\n        var spectra = result.spectra;\n        var existingGCMSFields = [];\n        var i;\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n            }\n        }\n        if (existingGCMSFields.length===0) return;\n        var gcms = {};\n        gcms.gc = {};\n        gcms.ms = [];\n        for (i = 0; i < existingGCMSFields.length; i++) {\n            gcms.gc[existingGCMSFields[i]] = [];\n        }\n        for (i = 0; i < spectra.length; i++) {\n            var spectrum = spectra[i];\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n            }\n          if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\n        }\n        result.gcms = gcms;\n    }\n\n    function prepareSpectrum(result, spectrum) {\n        if (!spectrum.xFactor) spectrum.xFactor = 1;\n        if (!spectrum.yFactor) spectrum.yFactor = 1;\n        if (spectrum.observeFrequency) {\n            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n                spectrum.xUnit = 'PPM';\n                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n            }\n        }\n        if (result.shiftOffsetVal) {\n            var shift = spectrum.firstX - result.shiftOffsetVal;\n            spectrum.firstX = spectrum.firstX - shift;\n            spectrum.lastX = spectrum.lastX - shift;\n        }\n    }\n\n\n\n    function convertTo3DZ(spectra) {\n        var noise = 0;\n        var minZ = spectra[0].data[0][0];\n        var maxZ = minZ;\n        var ySize = spectra.length;\n        var xSize = spectra[0].data[0].length / 2;\n        var z = new Array(ySize);\n        for (var i = 0; i < ySize; i++) {\n            z[i] = new Array(xSize);\n            var xVector=spectra[i].data[0];\n            for (var j = 0; j < xSize; j++) {\n                var value = xVector[j * 2 + 1];\n                z[i][j] = value;\n                if (value < minZ) minZ = value;\n                if (value > maxZ) maxZ = value;\n                if (i !== 0 && j !== 0) {\n                    noise += Math.abs(value - z[i][j - 1]) + Math.abs(value - z[i - 1][j]);\n                }\n            }\n        }\n        return {\n            z: z,\n            minX: spectra[0].data[0][0],\n            maxX: spectra[0].data[0][spectra[0].data[0].length - 2], // has to be -2 because it is a 1D array [x,y,x,y,...]\n            minY: spectra[0].pageValue,\n            maxY: spectra[ySize - 1].pageValue,\n            minZ: minZ,\n            maxZ: maxZ,\n            noise: noise / ((ySize - 1) * (xSize - 1) * 2)\n        };\n\n    }\n\n    function add2D(result) {\n        var zData = convertTo3DZ(result.spectra);\n        result.contourLines = generateContourLines(zData);\n        delete zData.z;\n        result.minMax = zData;\n    }\n\n\n    function generateContourLines(zData, options) {\n        // console.time('generateContourLines');\n        var noise = zData.noise;\n        var z = zData.z;\n        var contourLevels = [];\n        var nbLevels = 7;\n        var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n        var isOver0, isOver1, isOver2, isOver3;\n        var nbSubSpectra = z.length;\n        var nbPovars = z[0].length;\n        var pAx, pAy, pBx, pBy;\n\n        var x0 = zData.minX;\n        var xN = zData.maxX;\n        var dx = (xN - x0) / (nbPovars - 1);\n        var y0 = zData.minY;\n        var yN = zData.maxY;\n        var dy = (yN - y0) / (nbSubSpectra - 1);\n        var minZ = zData.minZ;\n        var maxZ = zData.maxZ;\n\n        //System.out.prvarln('y0 '+y0+' yN '+yN);\n        // -------------------------\n        // Povars attribution\n        //\n        // 0----1\n        // |  / |\n        // | /  |\n        // 2----3\n        //\n        // ---------------------d------\n\n        var lineZValue;\n        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n            var contourLevel = {};\n            contourLevels[level]=contourLevel;\n            var side = level % 2;\n            if (side === 0) {\n                lineZValue = (maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) + 5 * noise;\n            } else {\n                lineZValue = -(maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) - 5 * noise;\n            }\n            var lines = [];\n            contourLevel.zValue = lineZValue;\n            contourLevel.lines = lines;\n\n            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n                var subSpectra = z[iSubSpectra];\n                var subSpectraAfter = z[iSubSpectra + 1];\n                for (var povar = 0; povar < nbPovars - 1; povar++) {\n                    povarHeight0 = subSpectra[povar];\n                    povarHeight1 = subSpectra[povar + 1];\n                    povarHeight2 = subSpectraAfter[povar];\n                    povarHeight3 = subSpectraAfter[povar + 1];\n                    \n                    isOver0 = (povarHeight0 > lineZValue);\n                    isOver1 = (povarHeight1 > lineZValue);\n                    isOver2 = (povarHeight2 > lineZValue);\n                    isOver3 = (povarHeight3 > lineZValue);\n                    \n                    // Example povar0 is over the plane and povar1 and\n                    // povar2 are below, we find the varersections and add\n                    // the segment\n                    if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n                        pAx = povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n                        pAy = iSubSpectra;\n                        pBx = povar;\n                        pBy = iSubSpectra + (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n                        lines.push(pAx * dx + x0); lines.push(pAy * dy + y0); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                    }\n                    // remove push does not help !!!!\n                    if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n                        pAx = povar + 1;\n                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n                        pBx = povar + 1 - (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n                        pBy = iSubSpectra + 1;\n                        lines.push(pAx * dx + x0); lines.push(pAy * dy + y0); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                    }\n                    // test around the diagonal\n                    if (isOver1 !== isOver2) {\n                        pAx = (povar + 1 - (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dx + x0;\n                        pAy = (iSubSpectra + (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) * dy + y0;\n                        if (isOver1 !== isOver0) {\n                            pBx = povar + 1 - (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n                            pBy = iSubSpectra;\n                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver0) {\n                            pBx = povar;\n                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                        }\n                        if (isOver1 !== isOver3) {\n                            pBx = povar + 1;\n                            pBy = iSubSpectra + (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                        }\n                        if (isOver2 !== isOver3) {\n                            pBx = povar + (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n                            pBy = iSubSpectra + 1;\n                            lines.push(pAx); lines.push(pAy); lines.push(pBx * dx + x0); lines.push(pBy * dy + y0);\n                        }\n                    }\n                }\n            }\n        }\n        // console.timeEnd('generateContourLines');\n        return {\n            minX: zData.minX,\n            maxX: zData.maxX,\n            minY: zData.minY,\n            maxY: zData.maxY,\n            segments: contourLevels\n        };\n        //return contourLevels;\n    }\n\n\n    function addLowRes(spectra, options) {\n        var spectrum;\n        var averageX, averageY;\n        var targetNbPoints = options.lowRes;\n        var highResData;\n        for (var i = 0; i < spectra.length; i++) {\n            spectrum = spectra[i];\n            // we need to find the current higher resolution\n            if (spectrum.data.length > 0) {\n                highResData = spectrum.data[0];\n                for (var j = 1; j < spectrum.data.length; j++) {\n                    if (spectrum.data[j].length > highResData.length) {\n                        highResData = spectrum.data[j];\n                    }\n                }\n\n                if (targetNbPoints > (highResData.length / 2)) return;\n                var i, ii;\n                var lowResData = [];\n                var modulo = Math.ceil(highResData.length / (targetNbPoints * 2));\n                for (i = 0, ii = highResData.length; i < ii; i = i + 2) {\n                    if (i % modulo === 0) {\n                        lowResData.push(highResData[i], highResData[i + 1])\n                    }\n                }\n                spectrum.data.push(lowResData);\n            }\n        }\n    }\n\n    function fastParseXYData(spectrum, value) {\n        // TODO need to deal with result\n        //  console.log(value);\n        // we check if deltaX is defined otherwise we calculate it\n\n        var yFactor = spectrum.yFactor;\n        var deltaX = spectrum.deltaX;\n        \n\n        spectrum.isXYdata = true;\n        // TODO to be improved using 2 array {x:[], y:[]}\n        var currentData = [];\n        var currentPosition = 0;\n        spectrum.data = [currentData];\n\n\n        var currentX = spectrum.firstX;\n        var currentY = spectrum.firstY;\n\n        // we skip the first line\n        //\n        var endLine = false;\n        for (var i = 0; i < value.length; i++) {\n            var ascii = value.charCodeAt(i);\n            if (ascii === 13 || ascii === 10) {\n                endLine = true;\n            } else {\n                if (endLine) break;\n            }\n        }\n\n        // we proceed taking the i after the first line\n        var newLine = true;\n        var isDifference=false;\n        var isLastDifference=false;\n        var lastDifference=0;\n        var isDuplicate=false;\n        var inComment = false;\n        var currentValue = 0;\n        var isNegative = false;\n        var inValue=false;\n        var skipFirstValue=false;\n        var decimalPosition = 0;\n        var ascii;\n        for (; i <= value.length; i++) {\n            if (i===value.length) ascii=13;\n            else ascii = value.charCodeAt(i);\n            if (inComment) {\n                // we should ignore the text if we are after $$\n                if (ascii === 13 || ascii === 10) {\n                    newLine = true;\n                    inComment = false;\n                }\n            } else {\n                // when is it a new value ?\n                // when it is not a digit, . or comma\n                // it is a number that is either new or we continue\n                if ( ascii <= 57 && ascii >= 48) { // a number\n                    inValue=true;\n                    if (decimalPosition > 0) {\n                        currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n                    } else {\n                        currentValue *= 10;\n                        currentValue += ascii - 48;\n                    }\n                } else if (ascii === 44 || ascii === 46) { // a \",\" or \".\"\n                    inValue=true;\n                    decimalPosition++;\n                } else {\n                    if (inValue) {\n                        // need to process the previous value\n                        if (newLine) {\n                            newLine = false; // we don't check the X value\n                            // console.log(\"NEW LINE\",isDifference, lastDifference);\n                            // if new line and lastDifference, the first value is just a check !\n                            // that we don't check ...\n                            if (isLastDifference) skipFirstValue=true;\n                        } else {\n                            // need to deal with duplicate and differences\n                            if (skipFirstValue) {\n                                skipFirstValue=false;\n                            } else {\n                                if (isDifference) {\n                                    if (currentValue===0) lastDifference=0;\n                                    else lastDifference=isNegative ? -currentValue : currentValue;\n                                    isLastDifference=true;\n                                    isDifference=false;\n                                }\n                                var duplicate=isDuplicate ? currentValue - 1 : 1;\n                                for (var j=0; j<duplicate; j++) {\n                                    if (isLastDifference) {\n                                        currentY += lastDifference;\n                                    } else {\n                                        if (currentValue===0) currentY=0;\n                                        else currentY = isNegative ? -currentValue : currentValue;\n                                    }\n\n                                    //  console.log(\"Separator\",isNegative ?\n                                    //          -currentValue : currentValue,\n                                    //      \"isDiff\", isDifference, \"isDup\", isDuplicate,\n                                    //      \"lastDif\", lastDifference, \"dup:\", duplicate, \"y\", currentY);\n\n                                    // push is slightly slower ... (we loose 10%)\n                                    currentData[currentPosition++]=currentX;\n                                    currentData[currentPosition++]=currentY * yFactor;\n                                    currentX += deltaX;\n                                }\n                            }\n                        }\n                        isNegative=false;\n                        currentValue=0;\n                        decimalPosition=0;\n                        inValue=false;\n                        isDuplicate=false;\n                    }\n\n                    // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                    if ((ascii < 74) && (ascii > 63)) {\n                        inValue=true;\n                        isLastDifference=false;\n                        currentValue=ascii-64;\n                    } else\n                    // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                    if ((ascii > 96) && (ascii < 106)) {\n                        inValue=true;\n                        isLastDifference=false;\n                        currentValue=ascii-96;\n                        isNegative=true;\n                    } else\n                    // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                    if (ascii===115) {\n                        inValue=true;\n                        isDuplicate=true;\n                        currentValue=9;\n                    } else if ((ascii > 82) && (ascii < 91)) {\n                        inValue=true;\n                        isDuplicate=true;\n                        currentValue=ascii-82;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if ((ascii > 73) && (ascii < 83)) {\n                        inValue=true;\n                        isDifference=true;\n                        currentValue=ascii-73;\n                    } else\n                    // negative DIF digits j k l m n o p q r (ascii 106-114)\n                    if ((ascii > 105) && (ascii < 115)) {\n                        inValue=true;\n                        isDifference=true;\n                        currentValue=ascii-105;\n                        isNegative=true;\n                    } else\n                    // $ sign, we need to check the next one\n                    if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n                        inValue=true;\n                        inComment = true;\n                    } else\n                    // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                    if (ascii === 37) {\n                        inValue=true;\n                        isDifference=true;\n                        currentValue=0;\n                        isNegative=false;\n                    } else\n                    if (ascii === 45) { // a \"-\"\n                        // check if after there is a number, decimal or comma\n                        var ascii2=value.charCodeAt(i+1);\n                        if ((ascii2 >= 48 && ascii2 <= 57) || ascii2 === 44 || ascii2 === 46) {\n                            inValue=true;\n                            isLastDifference=false;\n                            isNegative = true;\n                        }\n                    } else if (ascii === 13 || ascii === 10) {\n                        newLine = true;\n                        inComment = false;\n                    }\n                    // and now analyse the details ... space or tabulation\n                    // if \"+\" we just don't care\n                }\n            }\n        }\n    }\n\n    function parsePeakTable(spectrum, value, result) {\n        var removeCommentRegExp = /\\$\\$.*/;\n        var peakTableSplitRegExp = /[,\\t ]+/;\n        \n        spectrum.isPeaktable=true;\n        var i, ii, j, jj, values;\n        var currentData = [];\n        spectrum.data = [currentData];\n\n        // counts for around 20% of the time\n        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n        var k = 0;\n        for (i = 1, ii = lines.length; i < ii; i++) {\n            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n            if (values.length % 2 === 0) {\n                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n                }\n            } else {\n                result.logs.push('Format error: ' + values);\n            }\n        }\n    }\n\n\n\n    return convert;\n\n}\n\nvar convert = getConverter();\n\nfunction JcampConverter(input, options, useWorker) {\n    if (typeof options === 'boolean') {\n        useWorker = options;\n        options = {};\n    }\n    if (useWorker) {\n        return postToWorker(input, options);\n    } else {\n        return convert(input, options);\n    }\n}\n\nvar stamps = {},\n    worker;\n\nfunction postToWorker(input, options) {\n    if (!worker) {\n        createWorker();\n    }\n    return new Promise(function (resolve) {\n        var stamp = Date.now() + '' + Math.random();\n        stamps[stamp] = resolve;\n        worker.postMessage({stamp: stamp, input: input, options: options});\n    });\n}\n\nfunction createWorker() {\n    var workerURL = URL.createObjectURL(new Blob([\n        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { postMessage({stamp: event.data.stamp, output: convert(event.data.input, event.data.options)}); };'\n    ], {type: 'application/javascript'}));\n    worker = new Worker(workerURL);\n    URL.revokeObjectURL(workerURL);\n    worker.addEventListener('message', function (event) {\n        var stamp = event.data.stamp;\n        if (stamps[stamp]) {\n            stamps[stamp](event.data.output);\n        }\n    });\n}\n\nmodule.exports = {\n    convert: JcampConverter\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\n\nvar xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\nvar removeCommentRegExp = /\\$\\$.*/;\nvar DEBUG=false;\n\nmodule.exports=function(spectrum, value, result) {\n    // we check if deltaX is defined otherwise we calculate it\n    if (!spectrum.deltaX) {\n        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n    }\n\n    spectrum.isXYdata=true;\n\n    var currentData = [];\n    var currentPosition=0;\n    spectrum.data = [currentData];\n\n    var currentX = spectrum.firstX;\n    var currentY = spectrum.firstY;\n    var lines = value.split(/[\\r\\n]+/);\n    var lastDif, values, ascii, expectedY;\n    values = [];\n    for (var i = 1, ii = lines.length; i < ii; i++) {\n        //var previousValues=JSON.parse(JSON.stringify(values));\n        values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n        if (values.length > 0) {\n            if (DEBUG) {\n                if (!spectrum.firstPoint) {\n                    spectrum.firstPoint = +values[0];\n                }\n                var expectedCurrentX = (values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n                if ((lastDif || lastDif === 0)) {\n                    expectedCurrentX += spectrum.deltaX;\n                }\n                result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n            }\n            for (var j = 1, jj = values.length; j < jj; j++) {\n                if (j === 1 && (lastDif || lastDif === 0)) {\n                    lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n                    // we could check if we have the expected Y value\n                    ascii = values[j].charCodeAt(0);\n\n                    if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n                        // + - . 0 1 2 3 4 5 6 7 8 9\n                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                            expectedY = +values[j];\n                        } else\n                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                        if ((ascii > 63) && (ascii < 74)) {\n                            expectedY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                        } else\n                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                        if ((ascii > 96) && (ascii < 106)) {\n                            expectedY = -(String.fromCharCode(ascii - 48) + values[j].substring(1));\n                        }\n                        if (expectedY !== currentY) {\n                            result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n                            result.logs.push('Previous values: ' + previousValues.length);\n                            result.logs.push(previousValues);\n                        }\n                    }\n                } else {\n                    if (values[j].length > 0) {\n                        ascii = values[j].charCodeAt(0);\n                        // + - . 0 1 2 3 4 5 6 7 8 9\n                        if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                            lastDif = null;\n                            currentY = +values[j];\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                        if ((ascii > 63) && (ascii < 74)) {\n                            lastDif = null;\n                            currentY = +(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++] = currentX;\n                            currentData[currentPosition++] = currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                        if ((ascii > 96) && (ascii < 106)) {\n                            lastDif = null;\n                            // we can multiply the string by 1 because if may not contain decimal (is this correct ????)\n                            currentY = -(String.fromCharCode(ascii - 48) + values[j].substring(1))*1;\n                            //currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n\n\n\n                        // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                        if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n                            var dup = (String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n                            if (ascii === 115) {\n                                dup = ('9' + values[j].substring(1)) - 1;\n                            }\n                            for (var l = 0; l < dup; l++) {\n                                if (lastDif) {\n                                    currentY = currentY + lastDif;\n                                }\n                                // currentData.push(currentX, currentY * spectrum.yFactor);\n                                currentData[currentPosition++]=currentX;\n                                currentData[currentPosition++]=currentY * spectrum.yFactor;\n                                currentX += spectrum.deltaX;\n                            }\n                        } else\n                        // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                        if (ascii === 37) {\n                            lastDif = +('0' + values[j].substring(1));\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else if ((ascii > 73) && (ascii < 83)) {\n                            lastDif = (String.fromCharCode(ascii - 25) + values[j].substring(1))*1;\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        } else\n                        // negative DIF digits j k l m n o p q r (ascii 106-114)\n                        if ((ascii > 105) && (ascii < 115)) {\n                            lastDif = -(String.fromCharCode(ascii - 57) + values[j].substring(1))*1;\n                            currentY += lastDif;\n                            // currentData.push(currentX, currentY * spectrum.yFactor);\n                            currentData[currentPosition++]=currentX;\n                            currentData[currentPosition++]=currentY * spectrum.yFactor;\n                            currentX += spectrum.deltaX;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parseXYData.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}